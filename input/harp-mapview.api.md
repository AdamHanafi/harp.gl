## API Report File for "@here/harp-mapview"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { BufferAttribute } from '@here/harp-datasource-protocol';
import { CachedResource } from '@here/harp-utils';
import { DecodedTile } from '@here/harp-datasource-protocol';
import { Definitions } from '@here/harp-datasource-protocol';
import { Env } from '@here/harp-datasource-protocol';
import { Expr } from '@here/harp-datasource-protocol';
import { ExprPool } from '@here/harp-datasource-protocol/lib/ExprPool';
import { ExtrudedPolygonTechnique } from '@here/harp-datasource-protocol';
import { FlatTheme } from '@here/harp-datasource-protocol/lib/Theme';
import { FontCatalog } from '@here/harp-text-canvas';
import { GeoBox } from '@here/harp-geoutils';
import { GeoBoxExtentLike } from '@here/harp-geoutils';
import { GeoCoordinates } from '@here/harp-geoutils';
import { GeoCoordLike } from '@here/harp-geoutils';
import { GeoJson } from '@here/harp-datasource-protocol';
import { GeometryKind } from '@here/harp-datasource-protocol';
import { GeometryKindSet } from '@here/harp-datasource-protocol';
import { GeometryType } from '@here/harp-datasource-protocol';
import { GlyphData } from '@here/harp-text-canvas';
import { GroupedPriorityList } from '@here/harp-utils';
import { IBloomEffect } from '@here/harp-datasource-protocol';
import { ILogger } from '@here/harp-utils';
import { ImageTexture } from '@here/harp-datasource-protocol';
import { IndexedTechniqueParams } from '@here/harp-datasource-protocol';
import { IOutlineEffect } from '@here/harp-datasource-protocol';
import { ISepiaEffect } from '@here/harp-datasource-protocol';
import { ISimpleChannel } from '@here/harp-utils';
import { ITileDecoder } from '@here/harp-datasource-protocol';
import { ITiler } from '@here/harp-datasource-protocol';
import { ITransferManager } from '@here/harp-transfer-manager';
import { IVignetteEffect } from '@here/harp-datasource-protocol';
import { LineMarkerTechnique } from '@here/harp-datasource-protocol';
import { Math2D } from '@here/harp-utils';
import { MemoryUsage } from '@here/harp-text-canvas';
import { OptionsMap } from '@here/harp-datasource-protocol';
import { OrientedBox3 } from '@here/harp-geoutils';
import { PoiStackMode } from '@here/harp-datasource-protocol';
import { PoiTableEntryDef } from '@here/harp-datasource-protocol';
import { PoiTechnique } from '@here/harp-datasource-protocol';
import { PostEffects } from '@here/harp-datasource-protocol';
import { PriorityListGroup } from '@here/harp-utils';
import { Projection } from '@here/harp-geoutils';
import { RequestController } from '@here/harp-datasource-protocol';
import { StyleSet } from '@here/harp-datasource-protocol';
import { Technique } from '@here/harp-datasource-protocol';
import { TextBufferObject } from '@here/harp-text-canvas';
import { TextCanvas } from '@here/harp-text-canvas';
import { TextLayoutParameters } from '@here/harp-text-canvas';
import { TextLayoutStyle } from '@here/harp-text-canvas';
import { TextPathGeometry } from '@here/harp-datasource-protocol';
import { TextRenderParameters } from '@here/harp-text-canvas';
import { TextRenderStyle } from '@here/harp-text-canvas';
import { TextTechnique } from '@here/harp-datasource-protocol';
import { Theme } from '@here/harp-datasource-protocol';
import { Theme as Theme_2 } from '@here/harp-datasource-protocol/lib/Theme';
import * as THREE_2 from 'three';
import { TileInfo } from '@here/harp-datasource-protocol';
import { TileKey } from '@here/harp-geoutils';
import { TileKey as TileKey_2 } from '@here/harp-geoutils/lib/tiling/TileKey';
import { TilingScheme } from '@here/harp-geoutils';
import { UriResolver } from '@here/harp-utils';
import { Value } from '@here/harp-datasource-protocol';
import { ValueMap } from '@here/harp-datasource-protocol';
import { Vector3Like } from '@here/harp-geoutils';
import { ViewRanges } from '@here/harp-datasource-protocol/lib/ViewRanges';
import { WorkerServiceProtocol } from '@here/harp-datasource-protocol';

// @public
export class AnimatedExtrusionHandler {
    constructor(m_mapView: MapView);
    add(tileHandler: AnimatedExtrusionTileHandler): void;
    duration: number;
    enabled: boolean;
    find(tileKeys: Array<TileKey | undefined>): AnimatedExtrusionTileHandler | undefined;
    get forceAnimatedExtrusion(): boolean | undefined;
    set forceAnimatedExtrusion(animatedExtrusion: boolean | undefined);
    get forceAnimatedExtrusionDuration(): number | undefined;
    set forceAnimatedExtrusionDuration(extrusionDuration: number | undefined);
    forceEnabled: boolean;
    get isAnimating(): boolean;
    removeTile(tile: Tile): void;
    set zoom(zoomLevel: number);
    get zoomDirection(): number;
}

// @public
export enum AnimatedExtrusionState {
    // (undocumented)
    Finished = 3,
    // (undocumented)
    None = 0,
    // (undocumented)
    Playing = 2,
    // (undocumented)
    Started = 1
}

// @public
export class AnimatedExtrusionTileHandler {
    constructor(m_tile: Tile, extrudedObjects: Array<{
        object: THREE_2.Object3D;
        materialFeature: boolean;
    }>, m_animatedExtrusionDuration: number);
    get animationState(): AnimatedExtrusionState;
    dispose(): void;
    set extrusionRatio(value: number);
    get isAnimating(): boolean;
    get tile(): Tile;
    zoomLevelChanged(zoomDirection: number): void;
}

// @public
export function applyBaseColorToMaterial(material: THREE_2.Material, materialColor: THREE_2.Color, technique: Technique, techniqueColor: Value, env?: Env): void;

// @public
export function applySecondaryColorToMaterial(materialColor: THREE_2.Color, techniqueColor: Value | Expr, env?: Env): void;

// @public
export interface AreaCopyrightInfo {
    alt?: string;
    boxes?: Array<[number, number, number, number]>;
    label: string;
    maxLevel?: number;
    minLevel?: number;
}

// @public
export enum AtmosphereLightMode {
    // (undocumented)
    LightDynamic = 1,
    // (undocumented)
    LightOverhead = 0
}

// @public
export const BASE_TECHNIQUE_NON_MATERIAL_PROPS: string[];

// @public
export abstract class BufferedGeometryAccessor extends BufferedGeometryAccessorBase {
    constructor(object: THREE_2.Mesh, geometryType: GeometryType, bufferGeometry: THREE_2.BufferGeometry, stride: number);
    // (undocumented)
    protected readonly bufferGeometry: THREE_2.BufferGeometry;
    // (undocumented)
    protected checkSetUp(): boolean;
    // (undocumented)
    clear(): void;
    // (undocumented)
    readonly geometryType: GeometryType;
    // (undocumented)
    getVertices(): Float32Array | undefined;
    // (undocumented)
    readonly object: THREE_2.Mesh;
    // (undocumented)
    protected stride: number;
}

// @public
export abstract class BufferedGeometryAccessorBase implements IGeometryAccessor {
    constructor(object: THREE_2.Mesh, geometryType: GeometryType, bufferGeometry: THREE_2.BufferGeometry);
    // (undocumented)
    protected readonly bufferGeometry: THREE_2.BufferGeometry;
    get color(): THREE_2.Color | undefined | Array<THREE_2.Color | undefined>;
    // (undocumented)
    protected end: number;
    // (undocumented)
    protected endCapSize: number;
    // (undocumented)
    readonly geometryType: GeometryType;
    getCount(): number;
    // (undocumented)
    protected itemSize: number;
    // (undocumented)
    readonly object: THREE_2.Mesh;
    // (undocumented)
    protected position: THREE_2.BufferAttribute;
    get renderOrder(): number;
    // (undocumented)
    setRange(start: number, end: number, startCapSize?: number, endCapSize?: number): void;
    // (undocumented)
    protected start: number;
    // (undocumented)
    protected startCapSize: number;
}

// @public
export class BufferedGeometryLineAccessor extends BufferedGeometryAccessor implements ILineAccessor {
    constructor(object: THREE_2.Mesh, geometryType: GeometryType, bufferGeometry: THREE_2.BufferGeometry);
    // (undocumented)
    readonly bufferGeometry: THREE_2.BufferGeometry;
    // (undocumented)
    readonly geometryType: GeometryType;
    // (undocumented)
    isLineAccessor(): boolean;
    // (undocumented)
    readonly object: THREE_2.Mesh;
    // (undocumented)
    get width(): number | undefined;
}

// @public
export class BufferedGeometryObject3dAccessor extends BufferedGeometryAccessor implements IObject3dAccessor {
    constructor(object: THREE_2.Mesh, geometryType: GeometryType, bufferGeometry: THREE_2.BufferGeometry);
    // (undocumented)
    readonly bufferGeometry: THREE_2.BufferGeometry;
    // (undocumented)
    readonly geometryType: GeometryType;
    // @override (undocumented)
    getVertices(): Float32Array | undefined;
    // (undocumented)
    isObject3dAccessor(): boolean;
    // (undocumented)
    readonly object: THREE_2.Mesh;
}

// @public
export function buildMetricValueEvaluator(value: Expr | Value | undefined, metricUnit: string | undefined): string | number | boolean | object | null | undefined;

// @public
export function buildObject(technique: Technique, geometry: THREE_2.BufferGeometry, material: THREE_2.Material | THREE_2.Material[], tile: Tile, elevationEnabled: boolean): THREE_2.Object3D;

// @public
export enum CalculationStatus {
    // (undocumented)
    FinalPrecise = 1,
    // (undocumented)
    PendingApproximate = 0
}

// @public
export class CameraMovementDetector {
    constructor(m_throttlingTimeout: number | undefined, m_movementStartedFunc: (() => void) | undefined, m_movementFinishedFunc: (() => void) | undefined);
    get cameraIsMoving(): boolean;
    get cameraMovedLastFrame(): boolean;
    checkCameraMoved(mapView: MapView, now: number): boolean;
    clear(mapView: MapView): void;
    dispose(): void;
    forceMoved(): void;
    }

// @public
export class Circles extends MapViewPoints {
    // @override (undocumented)
    testPoint(point: THREE_2.Vector3, screenPosition: THREE_2.Vector2, pickCoordinates: THREE_2.Vector2, index: number, distance: number, intersects: THREE_2.Intersection[]): void;
}

// @public (undocumented)
export interface ClipPlanesEvaluator {
    evaluateClipPlanes(camera: THREE_2.Camera, projection: Projection, elevationProvider?: ElevationProvider): ViewRanges;
    maxElevation: number;
    minElevation: number;
}

// @public
export class ColorCache {
    clear(): void;
    getColor(colorCode: string | number): THREE_2.Color;
    static get instance(): ColorCache;
    get size(): number;
}

// @public
export function computeArrayAverage(samples: number[]): number | undefined;

// @public
export function computeArrayStats(samples: number[]): Stats | undefined;

// @public
export class ConcurrentDecoderFacade {
    static defaultScriptUrl: string;
    static defaultWorkerCount?: number;
    static destroy(): void;
    static destroyWorkerSet(scriptUrl: string): void;
    static getTileDecoder(decoderServiceType: string, scriptUrl?: string, workerCount?: number): ITileDecoder;
    static getWorkerSet(scriptUrl?: string, workerCount?: number): ConcurrentWorkerSet;
    }

// @public
export class ConcurrentTilerFacade {
    static defaultScriptUrl: string;
    static defaultWorkerCount: number;
    static destroy(): void;
    static destroyWorkerSet(scriptUrl: string): void;
    static getTiler(tilerServiceType: string, scriptUrl?: string, workerCount?: number): ITiler;
    static getWorkerSet(scriptUrl?: string, workerCount?: number): ConcurrentWorkerSet;
    }

// @public
export abstract class CopyrightCoverageProvider implements CopyrightProvider {
    abstract getCopyrightCoverageData(): Promise<AreaCopyrightInfo[]>;
    // (undocumented)
    getCopyrights(geoBox: GeoBox, level: number): Promise<CopyrightInfo[]>;
    // (undocumented)
    getTree(): Promise<any>;
    initRBush(entries: AreaCopyrightInfo[]): any;
    protected readonly logger: ILogger;
    }

// @public
export interface CopyrightCoverageResponse {
    // (undocumented)
    [scheme: string]: AreaCopyrightInfo[];
}

// @public
export class CopyrightElementHandler {
    constructor(element: string | HTMLElement, mapView?: MapView);
    attach(mapView: MapView): this;
    destroy(): void;
    detach(mapView: MapView): this;
    static install(element: string | HTMLElement, mapView?: MapView): CopyrightElementHandler;
    setDefaults(defaults: CopyrightInfo[] | undefined): this;
    setStaticCopyightInfo(staticInfo: CopyrightInfo[] | undefined): this;
    staticInfo: CopyrightInfo[] | undefined;
    update: () => void;
}

// @public
export interface CopyrightInfo {
    id: string;
    label?: string;
    link?: string;
    year?: number;
}

// @public (undocumented)
export namespace CopyrightInfo {
    export function formatAsHtml(copyrightInfo: CopyrightInfo[]): string;
    export function mergeArrays(a: CopyrightInfo[], b?: CopyrightInfo[]): CopyrightInfo[];
}

// @public
export interface CopyrightProvider {
    getCopyrights(geoBox: GeoBox, level: number): Promise<CopyrightInfo[]>;
}

// @public
export const createDefaultClipPlanesEvaluator: () => TiltViewClipPlanesEvaluator;

// @public
export function createDepthPrePassMaterial(baseMaterial: THREE_2.Material): THREE_2.Material;

// @public
export function createDepthPrePassMesh(mesh: THREE_2.Mesh): THREE_2.Mesh;

// @public
export function createMaterial(options: MaterialOptions, textureReadyCallback?: (texture: THREE_2.Texture) => void): THREE_2.Material | undefined;

// @public
export abstract class DataSource extends THREE_2.EventDispatcher {
    constructor(options?: DataSourceOptions);
    addGroundPlane: boolean;
    // (undocumented)
    allowOverlappingTiles: boolean;
    attach(mapView: MapView): void;
    cacheable: boolean;
    canGetTile(zoomLevel: number, tileKey: TileKey): boolean;
    clearCache(): void;
    clearFeatureState(): void;
    connect(): Promise<void>;
    detach(mapView: MapView): void;
    dispose(): void;
    enabled: boolean;
    // @internal (undocumented)
    readonly exprPool: ExprPool;
    getDataZoomLevel(zoomLevel: number): number;
    getFeatureState(featureId: number): ValueMap | undefined;
    abstract getTile(tileKey: TileKey): Tile | undefined;
    abstract getTilingScheme(): TilingScheme;
    isFullyCovering(): boolean;
    isVisible(zoomLevel: number): boolean;
    get mapView(): MapView;
    maxDataLevel: number;
    maxDisplayLevel: number;
    get maxGeometryHeight(): number;
    set maxGeometryHeight(value: number);
    // @deprecated
    get maxZoomLevel(): number;
    set maxZoomLevel(level: number);
    minDataLevel: number;
    minDisplayLevel: number;
    // @deprecated
    get minZoomLevel(): number;
    set minZoomLevel(level: number);
    name: string;
    get projection(): Projection;
    ready(): boolean;
    removeFeatureState(featureId: number): void;
    requestUpdate(): void;
    setEnableElevationOverlay(enable: boolean): void;
    setFeatureState(featureId: number, state: ValueMap): void;
    setLanguages(languages?: string[]): void;
    setPoliticalView(pov?: string): void;
    setStyleSet(styleSet?: StyleSet, definitions?: Definitions, languages?: string[]): void;
    setTheme(theme: Theme, languages?: string[]): void;
    shouldPreloadTiles(): boolean;
    shouldRenderText(zoomLevel: number, tileKey: TileKey): boolean;
    shouldSubdivide(zoomLevel: number, tileKey: TileKey): boolean;
    get storageLevelOffset(): number;
    set storageLevelOffset(levelOffset: number);
    get styleSetName(): string | undefined;
    set styleSetName(styleSetName: string | undefined);
    updateTile(tile: Tile): void;
    useGeometryLoader: boolean;
}

// @public
export interface DataSourceOptions {
    allowOverlappingTiles?: boolean;
    maxDataLevel?: number;
    maxDisplayLevel?: number;
    // @deprecated
    maxZoomLevel?: number;
    minDataLevel?: number;
    minDisplayLevel?: number;
    // @deprecated
    minZoomLevel?: number;
    name?: string;
    storageLevelOffset?: number;
    styleSetName?: string;
}

// @public
export interface DataSourceTileList {
    allVisibleTileLoaded: boolean;
    dataSource: DataSource;
    numTilesLoading: number;
    renderedTiles: Map<number, Tile>;
    storageLevel: number;
    visibleTiles: Tile[];
    zoomLevel: number;
}

// @public (undocumented)
export const DEFAULT_MAX_THEME_INTHERITANCE_DEPTH = 4;

// @public
export const DEFAULT_TEXT_DISTANCE_SCALE = 0.5;

// @public
export const DEPTH_PRE_PASS_STENCIL_MASK = 1;

// @public (undocumented)
export interface DisplacementMap {
    // (undocumented)
    buffer: Float32Array;
    // (undocumented)
    xCountVertices: number;
    // (undocumented)
    yCountVertices: number;
}

// @public
export abstract class ElevationBasedClipPlanesEvaluator implements ClipPlanesEvaluator {
    constructor(maxElevation: number, minElevation: number);
    // (undocumented)
    abstract evaluateClipPlanes(camera: THREE_2.Camera, projection: Projection, elevationProvider?: ElevationProvider): ViewRanges;
    set maxElevation(elevation: number);
    get maxElevation(): number;
    set minElevation(elevation: number);
    get minElevation(): number;
}

// @public (undocumented)
export interface ElevationProvider {
    clearCache(): void;
    getDisplacementMap(tileKey: TileKey): TileDisplacementMap | undefined;
    getHeight(geoPoint: GeoCoordinates, level?: number): number | undefined;
    // (undocumented)
    getTilingScheme(): TilingScheme | undefined;
    rayCast(x: number, y: number): THREE.Vector3 | undefined;
    sampleHeight(geoPoint: GeoCoordinates, tileDisplacementMap: TileDisplacementMap): number;
}

// @public
export interface ElevationRange {
    // (undocumented)
    calculationStatus?: CalculationStatus;
    // (undocumented)
    maxElevation: number;
    // (undocumented)
    minElevation: number;
}

// @public
export interface ElevationRangeSource {
    connect(): Promise<void>;
    getElevationRange(tileKey: TileKey_2): ElevationRange;
    getTilingScheme(): TilingScheme;
    ready(): boolean;
}

// @public
export function evaluateBaseColorProperty(technique: Technique, env: Env): number | undefined;

// @public
export function evaluateColorProperty(value: Value, env?: Env): number | undefined;

// @public (undocumented)
export type ExtendedMesh = THREE_2.Mesh & {
    displacement?: THREE_2.Vector3;
};

// @public (undocumented)
export const FALLBACK_RENDER_ORDER_OFFSET = 20000;

// @public
export class FixedClipPlanesEvaluator implements ClipPlanesEvaluator {
    constructor(minNear?: number, minFarOffset?: number);
    // @override (undocumented)
    evaluateClipPlanes(camera: THREE_2.Camera, projection: Projection, elevationProvider?: ElevationProvider): ViewRanges;
    // (undocumented)
    get farPlane(): number;
    set farPlane(fixedFar: number);
    set maxElevation(elevation: number);
    // (undocumented)
    get maxElevation(): number;
    set minElevation(elevation: number);
    // (undocumented)
    get minElevation(): number;
    // (undocumented)
    readonly minFar: number;
    // (undocumented)
    readonly minFarOffset: number;
    // (undocumented)
    readonly minNear: number;
    // (undocumented)
    get nearPlane(): number;
    set nearPlane(fixedNear: number);
}

// @public
export interface FovCalculation {
    fov: number;
    type: "fixed" | "dynamic";
}

// @public
export class FrameStats {
    addMessage(message: string): void;
    addValue(name: string, value: number): void;
    // (undocumented)
    readonly entries: Map<string, number>;
    getValue(name: string): number | undefined;
    // (undocumented)
    messages?: string[];
    reset(): void;
    setValue(name: string, value: number): void;
}

// @public
export class FrameStatsArray {
    constructor(capacity?: number);
    // (undocumented)
    addFrame(frameStats: FrameStats): void;
    // (undocumented)
    readonly capacity: number;
    // (undocumented)
    readonly frameEntries: Map<string, RingBuffer<number>>;
    // (undocumented)
    get length(): number;
    log(): void;
    // (undocumented)
    readonly messages: RingBuffer<string[] | undefined>;
    // (undocumented)
    reset(): void;
}

// @public
export function getBufferAttribute(attribute: BufferAttribute): THREE_2.BufferAttribute;

// @public
export function getFeatureDataSize(featureData: TileFeatureData): number;

// @public
export function getMaterialConstructor(technique: Technique, shadowsEnabled: boolean): MaterialConstructor | undefined;

// @public
export interface IGeometryAccessor {
    getCount(): number;
    setRange(start: number, end: number): void;
}

// @public
export interface ILineAccessor {
    clear(): void;
    color: THREE_2.Color | undefined | Array<THREE_2.Color | undefined>;
    geometryType: GeometryType;
    getVertices(): Float32Array | undefined;
    isLineAccessor(): boolean;
    renderOrder: number;
    width: number | undefined;
}

// @public
export class ImageCache {
    addImage(mapView: MapView, url: string, startLoading?: boolean): ImageItem | Promise<ImageItem | undefined> | undefined;
    clear(mapView: MapView): void;
    clearAll(): void;
    static dispose(): void;
    findImage(url: string): ImageItem | undefined;
    static get instance(): ImageCache;
    loadImage(imageItem: ImageItem): ImageItem | Promise<ImageItem | undefined>;
    registerImage(mapView: MapView, url: string, imageData: ImageData | ImageBitmap | undefined): ImageItem;
    get size(): number;
}

// @public
export interface ImageItem {
    imageData?: ImageData | ImageBitmap;
    loaded: boolean;
    loadingPromise?: Promise<ImageItem | undefined>;
    mipMaps?: ImageData[];
    url: string;
}

// @public (undocumented)
export namespace ImageItem {
    export function isLoading(imageItem: ImageItem): boolean;
}

// @public
export interface ImageOptions {
    flipH?: boolean;
    flipV?: boolean;
    height: number;
    opacity?: number;
    origin?: ImageOrigin;
    width: number;
    xOffset?: number;
    yOffset?: number;
}

// @public
export enum ImageOrigin {
    // (undocumented)
    BottomLeft = 1,
    // (undocumented)
    TopLeft = 0
}

// @public
export interface IMapAntialiasSettings {
    dynamicMsaaSamplingLevel?: MSAASampling;
    msaaEnabled: boolean;
    staticMsaaSamplingLevel?: MSAASampling;
}

// @public
export interface IMapRenderingManager extends IPassManager {
    bloom: IBloomEffect;
    dynamicMsaaSamplingLevel: MSAASampling;
    lowResPixelRatio?: number;
    msaaEnabled: boolean;
    outline: IOutlineEffect;
    render(renderer: THREE_2.WebGLRenderer, scene: THREE_2.Scene, camera: THREE_2.PerspectiveCamera | THREE_2.OrthographicCamera, isStaticFrame: boolean, time?: number): void;
    sepia: ISepiaEffect;
    staticMsaaSamplingLevel: MSAASampling;
    updateOutline(options: {
        thickness: number;
        color: string;
        ghostExtrudedPolygons: boolean;
    }): void;
    vignette: IVignetteEffect;
}

// @public
export abstract class IndexedBufferedGeometryAccessor extends BufferedGeometryAccessorBase {
    constructor(object: THREE_2.Mesh, geometryType: GeometryType, bufferGeometry: THREE_2.BufferGeometry, start?: number, end?: number);
    // (undocumented)
    protected readonly bufferGeometry: THREE_2.BufferGeometry;
    // (undocumented)
    protected checkSetUp(): boolean;
    // (undocumented)
    readonly geometryType: GeometryType;
    // @override
    getCount(): number;
    // (undocumented)
    indices: number[];
    // (undocumented)
    readonly object: THREE_2.Mesh;
}

// @public
export class IndexedBufferedGeometryLineAccessor extends IndexedBufferedGeometryAccessor implements ILineAccessor {
    constructor(object: THREE_2.Mesh, geometryType: GeometryType, bufferGeometry: THREE_2.BufferGeometry);
    // (undocumented)
    readonly bufferGeometry: THREE_2.BufferGeometry;
    // (undocumented)
    clear(): void;
    // (undocumented)
    readonly geometryType: GeometryType;
    // (undocumented)
    getVertices(): Float32Array | undefined;
    // (undocumented)
    isLineAccessor(): boolean;
    // (undocumented)
    readonly object: THREE_2.Mesh;
    get width(): number | undefined;
}

// @public @deprecated
export class InterpolatedClipPlanesEvaluator implements ClipPlanesEvaluator {
    constructor(nearMin?: number, nearMultiplier?: number, nearFarMultiplier?: number, farOffset?: number);
    // (undocumented)
    evaluateClipPlanes(camera: THREE_2.Camera, projection: Projection, elevationProvider?: ElevationProvider): ViewRanges;
    // (undocumented)
    readonly farMin: number;
    // (undocumented)
    readonly farOffset: number;
    // (undocumented)
    protected m_tmpQuaternion: THREE_2.Quaternion;
    // (undocumented)
    protected m_tmpVectors: THREE_2.Vector3[];
    set maxElevation(elevation: number);
    // (undocumented)
    get maxElevation(): number;
    set minElevation(elevation: number);
    // (undocumented)
    get minElevation(): number;
    // (undocumented)
    readonly nearFarMultiplier: number;
    // (undocumented)
    readonly nearMin: number;
    // (undocumented)
    readonly nearMultiplier: number;
}

// @public
export interface IObject3dAccessor {
    clear(): void;
    color: THREE_2.Color | undefined | Array<THREE_2.Color | undefined>;
    geometryType: GeometryType;
    // (undocumented)
    getVertices(): Float32Array | undefined;
    isObject3dAccessor(): boolean;
    renderOrder: number;
}

// @public
export interface IPass {
    enabled: boolean;
    render(renderer: THREE_2.WebGLRenderer, scene: THREE_2.Scene, camera: THREE_2.Camera, writeBuffer: THREE_2.WebGLRenderTarget | null, readBuffer: THREE_2.WebGLRenderTarget | null, delta?: number): void;
    renderToScreen: boolean;
    setSize(width: number, height: number): void;
}

// @public
export interface IPassManager {
    render(renderer: THREE_2.WebGLRenderer, ...args: any[]): void;
    setSize(width: number, height: number): void;
}

// @public
export function isLineAccessor(arg: any): arg is ILineAccessor;

// @public
export function isObject3dAccessor(arg: any): arg is IObject3dAccessor;

// @public
export function isRenderDepthPrePassEnabled(technique: ExtrudedPolygonTechnique, env: Env): boolean;

// @public
export interface ITileDataVisitor {
    // (undocumented)
    tile: Tile;
    visitArea(featureId: number | undefined): void;
    visitLine(featureId: number | undefined, lineAccessor: ILineAccessor): void;
    visitObject3D(featureId: number | undefined, object3dAccessor: IObject3dAccessor): void;
    visitPoint(featureId: number | undefined): void;
    wantsArea(featureId: number | undefined): boolean;
    wantsFeature(featureId: number | undefined): boolean;
    wantsLine(featureId: number | undefined): boolean;
    wantsObject3D(featureId: number | undefined): boolean;
    wantsPoint(featureId: number | undefined): boolean;
}

// @public (undocumented)
export interface ITileLoader {
    // (undocumented)
    cancel(): void;
    // (undocumented)
    decodedTile?: DecodedTile;
    // (undocumented)
    isFinished: boolean;
    // (undocumented)
    loadAndDecode(): Promise<TileLoaderState>;
    // (undocumented)
    payload?: ArrayBufferLike | {};
    // (undocumented)
    state: TileLoaderState;
    // (undocumented)
    updatePriority(area: number): void;
    // (undocumented)
    waitSettled(): Promise<TileLoaderState>;
}

// @public
export enum LoadingState {
    // (undocumented)
    Initialized = 2,
    // (undocumented)
    Loaded = 1,
    // (undocumented)
    Requested = 0
}

// @public
export interface LookAtParams {
    bounds: GeoBox | GeoBoxExtentLike | GeoCoordLike[];
    distance: number;
    heading: number;
    target: GeoCoordLike;
    tilt: number;
    zoomLevel: number;
}

// @public
export type MapAnchor<T extends THREE_2.Object3D = THREE_2.Object3D> = T & {
    geoPosition?: GeoCoordinates;
    pickable?: boolean;
};

// @public
export class MapRenderingManager implements IMapRenderingManager {
    constructor(width: number, height: number, lowResPixelRatio: number | undefined, antialiasSettings?: IMapAntialiasSettings | undefined);
    // (undocumented)
    bloom: {
        enabled: boolean;
        strength: number;
        radius: number;
        threshold: number;
    };
    set dynamicMsaaSamplingLevel(samplingLevel: MSAASampling);
    get dynamicMsaaSamplingLevel(): MSAASampling;
    get lowResPixelRatio(): number | undefined;
    set lowResPixelRatio(pixelRatio: number | undefined);
    set msaaEnabled(value: boolean);
    get msaaEnabled(): boolean;
    // (undocumented)
    outline: {
        enabled: boolean;
        thickness: number;
        color: string;
        ghostExtrudedPolygons: boolean;
        needsUpdate: boolean;
    };
    render(renderer: THREE_2.WebGLRenderer, scene: THREE_2.Scene, camera: THREE_2.PerspectiveCamera | THREE_2.OrthographicCamera, isStaticFrame: boolean): void;
    // (undocumented)
    sepia: {
        enabled: boolean;
        amount: number;
    };
    setSize(width: number, height: number): void;
    set staticMsaaSamplingLevel(samplingLevel: MSAASampling);
    get staticMsaaSamplingLevel(): MSAASampling;
    // (undocumented)
    updateOutline(options: {
        thickness: number;
        color: string;
        ghostExtrudedPolygons: boolean;
    }): void;
    // (undocumented)
    vignette: {
        enabled: boolean;
        offset: number;
        darkness: number;
    };
}

// @public
export class MapView extends THREE_2.EventDispatcher {
    constructor(options: MapViewOptions);
    addDataSource(dataSource: DataSource): Promise<void>;
    addEventListener(type: MapViewEventNames, listener: (event: RenderEvent) => void): void;
    addOverlayText(textElements: TextElement[]): void;
    get animatedExtrusionHandler(): AnimatedExtrusionHandler;
    get animating(): boolean;
    beginAnimation(): void;
    get camera(): THREE_2.PerspectiveCamera;
    get cameraIsMoving(): boolean;
    get cameraMovementDetector(): CameraMovementDetector;
    get canvas(): HTMLCanvasElement;
    get clearAlpha(): number;
    set clearAlpha(alpha: number);
    get clearColor(): number;
    set clearColor(color: number);
    clearElevationSource(elevationSource: DataSource): void;
    clearOverlayText(): void;
    clearTileCache(dataSourceName?: string): void;
    get clipPlanesEvaluator(): ClipPlanesEvaluator;
    set clipPlanesEvaluator(clipPlanesEvaluator: ClipPlanesEvaluator);
    get collisionDebugCanvas(): HTMLCanvasElement | undefined;
    // (undocumented)
    get copyrightInfo(): CopyrightInfo[];
    get dataSources(): DataSource[];
    // (undocumented)
    get delayLabelsUntilMovementFinished(): boolean;
    set delayLabelsUntilMovementFinished(value: boolean);
    set disableFading(disable: boolean);
    // (undocumented)
    get disableFading(): boolean;
    dispose(): void;
    set dynamicPixelRatio(ratio: number | undefined);
    // (undocumented)
    get dynamicPixelRatio(): number | undefined;
    get elevationProvider(): ElevationProvider | undefined;
    // (undocumented)
    get enableMixedLod(): boolean | undefined;
    set enableMixedLod(enableMixedLod: boolean | undefined);
    endAnimation(): void;
    get env(): Env;
    get extendedFrustumCulling(): boolean;
    set extendedFrustumCulling(value: boolean);
    get focalLength(): number;
    get fog(): MapViewFog;
    get forceCameraAspect(): number | undefined;
    set forceCameraAspect(aspect: number | undefined);
    forEachCachedTile(visitor: (tile: Tile) => void): void;
    forEachVisibleTile(fun: (tile: Tile) => void): void;
    get frameNumber(): number;
    // @internal
    get geoCenter(): GeoCoordinates;
    set geoCenter(geoCenter: GeoCoordinates);
    getCacheSize(): number;
    getDataSourceByName(dataSourceName: string): DataSource | undefined;
    getDataSourcesByStyleSetName(styleSetName: string): DataSource[];
    getGeoCoordinatesAt(x: number, y: number): GeoCoordinates | null;
    getNormalizedScreenCoordinates(x: number, y: number): THREE_2.Vector3;
    getScreenPosition(geoPos: GeoCoordinates): THREE_2.Vector2 | undefined;
    getWorldPositionAt(x: number, y: number): THREE_2.Vector3 | null;
    get heading(): number;
    set heading(heading: number);
    get imageCache(): MapViewImageCache;
    intersectMapObjects(x: number, y: number): PickResult[];
    isDataSourceEnabled(dataSource: DataSource): boolean;
    get isDynamicFrame(): boolean;
    get languages(): string[] | undefined;
    set languages(languages: string[] | undefined);
    // (undocumented)
    get lights(): THREE_2.Light[];
    loadPostEffects(postEffectsFile: string): void;
    get lockVisibleTileSet(): boolean;
    set lockVisibleTileSet(value: boolean);
    lookAt(params: Partial<LookAtParams>): void;
    // @deprecated
    lookAt(target: GeoCoordLike, distance: number, tiltDeg?: number, headingDeg?: number): void;
    get mapAnchors(): THREE_2.Object3D;
    readonly mapRenderingManager: IMapRenderingManager;
    markTilesDirty(dataSource?: DataSource): void;
    maxFps: number;
    get maxZoomLevel(): number;
    set maxZoomLevel(zoomLevel: number);
    get minCameraHeight(): number;
    get minZoomLevel(): number;
    set minZoomLevel(zoomLevel: number);
    get nativeWebglAntialiasEnabled(): boolean;
    get pickHandler(): PickHandler;
    // (undocumented)
    get pixelRatio(): number;
    set pixelRatio(pixelRatio: number);
    get pixelToWorld(): number;
    get poiManager(): PoiManager;
    get pointOfView(): THREE_2.PerspectiveCamera | undefined;
    set pointOfView(pointOfView: THREE_2.PerspectiveCamera | undefined);
    get poiTableManager(): PoiTableManager;
    get politicalView(): string | undefined;
    set politicalView(pov: string | undefined);
    get postEffects(): PostEffects | undefined;
    set postEffects(postEffects: PostEffects | undefined);
    get projection(): Projection;
    set projection(projection: Projection);
    // @alpha
    raycasterFromScreenPoint(x: number, y: number): THREE_2.Raycaster;
    removeDataSource(dataSource: DataSource): void;
    removeDynamicProperty(name: string): void;
    removeEventListener(type: MapViewEventNames, listener: (event: RenderEvent) => void): void;
    get renderer(): THREE_2.WebGLRenderer;
    // (undocumented)
    get renderLabels(): boolean;
    set renderLabels(value: boolean);
    renderSync(frameStartTime?: number): void;
    // @deprecated
    requestUpdateIfNeeded(): void;
    resetFrameNumber(): void;
    resize(width: number, height: number): void;
    get resourceComputationType(): ResourceComputationType;
    set resourceComputationType(value: ResourceComputationType);
    get scene(): THREE_2.Scene;
    setCacheSize(size: number, numVisibleTiles?: number): void;
    // @deprecated
    setCameraGeolocationAndZoom(geoPos: GeoCoordinates, zoomLevel: number, yawDeg?: number, pitchDeg?: number): void;
    setDynamicProperty(name: string, value: Value): void;
    setElevationSource(elevationSource: DataSource, elevationRangeSource: ElevationRangeSource, elevationProvider: ElevationProvider): Promise<void>;
    setFovCalculation(fovCalculation: FovCalculation): void;
    // (undocumented)
    get shadowsEnabled(): boolean;
    set shadowsEnabled(enabled: boolean);
    get storageLevel(): number;
    get target(): GeoCoordinates;
    // @internal
    get targetDistance(): number;
    get textElementsRenderer(): TextElementsRenderer;
    get theme(): Theme;
    set theme(theme: Theme);
    get tileGeometryManager(): TileGeometryManager | undefined;
    get tilt(): number;
    set tilt(tilt: number);
    update(): void;
    get updatePending(): boolean;
    get uriResolver(): UriResolver | undefined;
    get viewportHeight(): number;
    // @internal
    get viewRanges(): ViewRanges;
    get visibleTileSet(): VisibleTileSet;
    // @internal
    get worldAnchors(): THREE_2.Object3D;
    get worldCenter(): THREE_2.Vector3;
    // @internal
    get worldTarget(): THREE_2.Vector3;
    get worldToPixel(): number;
    get zoomLevel(): number;
    set zoomLevel(zoomLevel: number);
}

// @public
export class MapViewAtmosphere {
    constructor(m_sceneRoot: THREE_2.Object3D, m_sceneCamera: THREE_2.Camera, m_projection: Projection, m_updateCallback?: (() => void) | undefined, m_atmosphereVariant?: AtmosphereVariant, m_materialVariant?: AtmosphereShadingVariant);
    dispose(): void;
    set enabled(enable: boolean);
    get enabled(): boolean;
    static GroundAtmosphereUserName: string;
    // (undocumented)
    get groundMesh(): THREE_2.Mesh | undefined;
    static isPresent(where: THREE_2.Scene | THREE_2.Object3D): boolean;
    // (undocumented)
    set lightMode(lightMode: AtmosphereLightMode);
    reset(theme: Theme): void;
    static SkyAtmosphereUserName: string;
    // (undocumented)
    get skyMesh(): THREE_2.Mesh | undefined;
}

// @public (undocumented)
export enum MapViewEventNames {
    AfterRender = "didrender",
    AnimationFinished = "animation-finished",
    AnimationStarted = "animation-started",
    CameraPositionChanged = "camera-changed",
    ContextLost = "webglcontext-lost",
    ContextRestored = "webglcontext-restored",
    CopyrightChanged = "copyright-changed",
    DataSourceConnect = "datasource-connect",
    FirstFrame = "first-render",
    FrameComplete = "frame-complete",
    MovementFinished = "movement-finished",
    MovementStarted = "movement-started",
    Render = "render",
    Resize = "resize",
    ThemeLoaded = "theme-loaded",
    Update = "update"
}

// @public
export class MapViewFog {
    constructor(m_scene: THREE_2.Scene);
    set enabled(enableFog: boolean);
    get enabled(): boolean;
    reset(theme: Theme): void;
    update(mapView: MapView, viewDistance?: number): void;
}

// @public
export class MapViewImageCache {
    constructor(mapView: MapView);
    addImage(name: string, url: string, startLoading?: boolean): ImageItem | Promise<ImageItem | undefined>;
    clear(): void;
    findImageByName(name: string): ImageItem | undefined;
    findImageByUrl(url: string): ImageItem | undefined;
    findNames(url: string): string[] | undefined;
    hasName(name: string): boolean;
    hasUrl(url: string): boolean;
    loadImage(imageItem: ImageItem): ImageItem | Promise<ImageItem | undefined>;
    // (undocumented)
    mapView: MapView;
    get numberOfNames(): number;
    get numberOfUrls(): number;
    registerImage(name: string | undefined, url: string, image: ImageData | ImageBitmap | undefined): ImageItem;
}

// @public
export interface MapViewOptions extends TextElementsRendererOptions, Partial<LookAtParams> {
    addBackgroundDatasource?: boolean;
    alpha?: boolean;
    backgroundTilingScheme?: TilingScheme;
    canvas: HTMLCanvasElement;
    clipPlanesEvaluator?: ClipPlanesEvaluator;
    collisionDebugCanvas?: HTMLCanvasElement;
    context?: WebGLRenderingContext;
    customAntialiasSettings?: IMapAntialiasSettings;
    decoderCount?: number;
    decoderUrl?: string;
    dynamicPixelRatio?: number;
    enableMixedLod?: boolean;
    enableNativeWebglAntialias?: boolean;
    enablePickTechnique?: boolean;
    enablePolarDataSource?: boolean;
    // @deprecated (undocumented)
    enableRoadPicking?: boolean;
    enableShadows?: boolean;
    enableStatistics?: boolean;
    extendedFrustumCulling?: boolean;
    fovCalculation?: FovCalculation;
    // (undocumented)
    languages?: string[];
    maxFps?: number;
    maxVisibleDataSourceTiles?: number;
    maxZoomLevel?: number;
    minCameraHeight?: number;
    minZoomLevel?: number;
    movementThrottleTimeout?: number;
    pixelRatio?: number;
    polarGeometryLevelOffset?: number;
    polarStyleSetName?: string;
    politicalView?: string;
    powerPreference?: MapViewPowerPreference;
    preserveDrawingBuffer?: boolean;
    projection?: Projection;
    quadTreeSearchDistanceDown?: number;
    quadTreeSearchDistanceUp?: number;
    resourceComputationType?: ResourceComputationType;
    synchronousRendering?: boolean;
    theme?: string | Theme | Promise<Theme>;
    tileCacheSize?: number;
    tileWrappingEnabled?: boolean;
    uriResolver?: UriResolver;
}

// @public
export abstract class MapViewPoints extends THREE_2.Points {
    enableRayTesting: boolean;
    raycast(raycaster: PickingRaycaster, intersects: THREE_2.Intersection[]): void;
    abstract testPoint(point: THREE_2.Vector3, screenPosition: THREE_2.Vector2, pickCoordinates: THREE_2.Vector2, index: number, distance: number, intersects: THREE_2.Intersection[]): void;
}

// @public
export enum MapViewPowerPreference {
    Default = "default",
    HighPerformance = "high-performance",
    LowPower = "low-power"
}

// @public (undocumented)
export namespace MapViewUtils {
    const // (undocumented)
    MAX_TILT_DEG = 89;
    const // (undocumented)
    MAX_TILT_RAD: number;
    export interface Attitude {
        pitch: number;
        roll: number;
        yaw: number;
    }
    export function calculateDepthFromClipDistance(clipDistance: number, camera: THREE_2.Camera): number;
    export function calculateDistanceFromZoomLevel(options: {
        focalLength: number;
    }, zoomLevel: number): number;
    export function calculateDistanceToGroundFromZoomLevel(options: {
        projection: Projection;
        focalLength: number;
        camera: THREE_2.Object3D;
    }, zoomLevel: number): number;
    export function calculateFocalLengthByVerticalFov(vFov: number, height: number): number;
    export function calculateFovByFocalLength(focalLength: number, height: number): number;
    export function calculateHorizontalFovByVerticalFov(vFov: number, aspect: number): number;
    export function calculateScreenSizeByFocalLength(focalLength: number, distance: number, worldSize: number): number;
    export function calculateVerticalFovByHorizontalFov(hFov: number, aspect: number): number;
    export function calculateWorldSizeByFocalLength(focalLength: number, distance: number, screenSize: number): number;
    export function calculateZoomLevelFromDistance(options: {
        focalLength: number;
        minZoomLevel: number;
        maxZoomLevel: number;
    }, distance: number): number;
    export function cameraToWorldDistance(distance: number, camera: THREE_2.Camera): number;
    export function estimateObject3dSize(object: THREE_2.Object3D, parentSize?: MemoryUsage, visitedObjects?: Map<string, boolean>): MemoryUsage;
    export function extractAttitude(options: {
        projection: Projection;
    }, object: THREE_2.Object3D): Attitude;
    // @deprecated
    export function extractCameraTilt(camera: THREE_2.Camera, projection: Projection): number;
    export function extractSphericalCoordinatesFromLocation(mapView: MapView, object: THREE_2.Object3D, location: GeoCoordinates): {
        azimuth: number;
        tilt: number;
    };
    export function extractTiltAngleFromLocation(projection: Projection, object: THREE_2.Object3D, location: GeoCoordinates): number;
    // @internal
    export interface FitPointParams {
        // (undocumented)
        camera: THREE_2.PerspectiveCamera;
        // (undocumented)
        heading: number;
        // (undocumented)
        minDistance: number;
        // (undocumented)
        projection: Projection;
        // (undocumented)
        tilt: number;
    }
    // @internal
    export function geoBoxToGeoPoints(box: GeoBox): GeoCoordinates[];
    export function getBrowserLanguages(): string[] | undefined;
    // @deprecated (undocumented)
    export function getCameraCoordinatesFromTargetCoordinates(targetCoordinates: GeoCoordinates, distance: number, yawDeg: number, pitchDeg: number, mapView: MapView): GeoCoordinates;
    export function getCameraFrustumPlanes(camera: THREE_2.PerspectiveCamera): {
        left: number;
        right: number;
        top: number;
        bottom: number;
        near: number;
        far: number;
    };
    export function getCameraPositionFromTargetCoordinates(targetCoordinates: GeoCoordinates, distance: number, yawDeg: number, pitchDeg: number, projection: Projection, result?: THREE_2.Vector3): THREE_2.Vector3;
    export function getCameraRotationAtTarget(projection: Projection, target: GeoCoordinates, yawDeg: number, pitchDeg: number, result?: THREE_2.Quaternion): THREE_2.Quaternion;
    // @internal
    export function getFitBoundsDistance(points: THREE_2.Vector3[], worldTarget: THREE_2.Vector3, camera: THREE_2.PerspectiveCamera): number;
    // @internal
    export function getFitBoundsLookAtParams(geoTarget: GeoCoordinates, worldTarget: THREE_2.Vector3, worldPoints: THREE_2.Vector3[], params: FitPointParams): {
        target: GeoCoordinates;
        distance: number;
        heading: number;
        tilt: number;
    };
    // @deprecated
    export function getGeoTargetFromCamera(camera: THREE_2.Camera, projection: Projection, elevation?: number): GeoCoordinates | null;
    // @internal @deprecated (undocumented)
    export function getTargetAndDistance(projection: Projection, camera: THREE_2.Camera, elevationProvider?: ElevationProvider): {
        target: THREE_2.Vector3;
        distance: number;
    };
    // @deprecated
    export function getWorldTargetFromCamera(camera: THREE_2.Camera, projection: Projection, elevation?: number): THREE_2.Vector3 | null;
    export function mapViewIsLoading(mapView: MapView): boolean;
    export interface MemoryUsage {
        // (undocumented)
        gpuSize: number;
        // (undocumented)
        heapSize: number;
    }
    export function orbitFocusPoint(mapView: MapView, deltaAzimuthDeg: number, deltaTiltDeg: number, maxTiltAngleRad?: number): void;
    export function panCameraAboveFlatMap(mapView: MapView, offsetX: number, offsetY: number): void;
    export function panCameraAroundGlobe(mapView: MapView, fromWorld: THREE_2.Vector3, toWorld: THREE_2.Vector3): void;
    export function rayCastGeoCoordinates(mapView: MapView, pointOnScreenXinNDC: number, pointOnScreenYinNDC: number): GeoCoordinates | null;
    export function rayCastWorldCoordinates(mapView: MapView, pointOnScreenXinNDC: number, pointOnScreenYinNDC: number, elevation?: number): THREE_2.Vector3 | null;
    export function rotate(mapView: MapView, deltaYawDeg: number, deltaPitchDeg?: number, maxTiltAngleRad?: number): void;
    export function setRotation(mapView: MapView, yawDeg: number, pitchDeg: number): void;
    // @internal
    export function wrapGeoPointsToScreen(points: GeoCoordLike[], startPosition?: GeoCoordinates): GeoCoordinates[];
    // @internal
    export function wrapWorldPointsToView(points: THREE_2.Vector3[], cameraPos: THREE_2.Vector3): void;
    export function zoomOnTargetPosition(mapView: MapView, targetNDCx: number, targetNDCy: number, zoomLevel: number, maxTiltAngle?: number): void;
}

// @public
export type MaterialConstructor = new (params?: {}) => THREE_2.Material;

// @public
export interface MaterialOptions {
    env: Env;
    fog?: boolean;
    shadowsEnabled?: boolean;
    skipExtraProps?: string[];
    technique: Technique;
}

// @public
export class MSAARenderPass extends Pass {
    constructor();
    dispose(): void;
    static readonly OffsetVectors: number[][][];
    // @override
    render(renderer: THREE_2.WebGLRenderer, scene: THREE_2.Scene, camera: THREE_2.PerspectiveCamera | THREE_2.OrthographicCamera, writeBuffer: THREE_2.WebGLRenderTarget | null, readBuffer: THREE_2.WebGLRenderTarget): void;
    samplingLevel: MSAASampling;
    // @override
    setSize(width: number, height: number): void;
}

// @public
export enum MSAASampling {
    // (undocumented)
    "Level_0" = 0,
    // (undocumented)
    "Level_1" = 1,
    // (undocumented)
    "Level_2" = 2,
    // (undocumented)
    "Level_3" = 3,
    // (undocumented)
    "Level_4" = 4,
    // (undocumented)
    "Level_5" = 5
}

// @public
export class MultiStageTimer {
    constructor(statistics: Statistics, name: string, stages: string[]);
    // (undocumented)
    readonly name: string;
    reset(): void;
    get stage(): string | undefined;
    set stage(stage: string | undefined);
    // (undocumented)
    stages: string[];
    start(): number;
    stop(): number;
    get value(): number | undefined;
}

// @public
export class Pass implements IPass {
    // (undocumented)
    enabled: boolean;
    // (undocumented)
    render(renderer: THREE_2.WebGLRenderer, scene: THREE_2.Scene, camera: THREE_2.Camera, writeBuffer: THREE_2.WebGLRenderTarget | null, readBuffer: THREE_2.WebGLRenderTarget | null, delta?: number): void;
    // (undocumented)
    renderToScreen: boolean;
    // (undocumented)
    setSize(width: number, height: number): void;
}

// @public
export class PerformanceStatistics {
    constructor(enabled?: boolean, maxNumFrames?: number);
    addMemoryInfo(): void;
    addWebGLInfo(webGlInfo: THREE_2.WebGLInfo): void;
    readonly appResults: Map<string, number>;
    clear(): void;
    clearFrames(): void;
    readonly configs: Map<string, string>;
    readonly currentFrame: FrameStats;
    // (undocumented)
    enabled: boolean;
    get frameEvents(): FrameStatsArray;
    getAsPlainObject(onlyLastFrame?: boolean): any;
    getAsSimpleFrameStatistics(onlyLastFrame?: boolean): SimpleFrameStatistics;
    getLastFrameStatistics(): any;
    static get instance(): PerformanceStatistics;
    get isFull(): boolean;
    log(header?: string, footer?: string): void;
    // (undocumented)
    maxNumFrames: number;
    storeAndClearFrameInfo(): boolean;
}

// @internal
export class PickHandler {
    constructor(mapView: MapView, camera: THREE_2.Camera, enablePickTechnique?: boolean);
    // (undocumented)
    readonly camera: THREE_2.Camera;
    // (undocumented)
    enablePickTechnique: boolean;
    intersectMapObjects(x: number, y: number): PickResult[];
    // (undocumented)
    readonly mapView: MapView;
}

// @public
export enum PickObjectType {
    Area = 3,
    Icon = 5,
    Line = 2,
    Object3D = 6,
    Point = 1,
    Text = 4,
    Unspecified = 0
}

// @public
export interface PickResult {
    distance: number;
    featureId?: number;
    intersection?: THREE_2.Intersection;
    point: THREE_2.Vector2 | THREE_2.Vector3;
    technique?: Technique;
    type: PickObjectType;
    userData?: any;
}

// @public
export interface PoiInfo {
    computedHeight?: number;
    computedWidth?: number;
    featureId?: number;
    iconBrightness?: number;
    iconColor?: THREE_2.Color;
    iconIsOptional?: boolean;
    iconMaxZoomLevel?: number;
    iconMinZoomLevel?: number;
    imageItem?: ImageItem;
    imageTexture?: ImageTexture;
    imageTextureName: string;
    isValid?: boolean;
    mayOverlap?: boolean;
    poiName?: string;
    poiRenderBatch?: number;
    poiTableName?: string;
    renderOrder?: number;
    renderTextDuringMovements?: boolean;
    reserveSpace?: boolean;
    shieldGroupIndex?: number;
    stackMode?: PoiStackMode;
    technique: PoiTechnique | LineMarkerTechnique;
    textElement: TextElement;
    textIsOptional?: boolean;
    textMaxZoomLevel?: number;
    textMinZoomLevel?: number;
    uvBox?: Math2D.UvBox;
}

// @public
export function poiIsRenderable(poiInfo: PoiInfo): boolean;

// @public
export class PoiManager {
    constructor(mapView: MapView);
    addImageTexture(imageTexture: ImageTexture): void;
    addPois(tile: Tile, decodedTile: DecodedTile): void;
    addTextureAtlas(imageName: string, atlas: string): void;
    clear(): void;
    getImageTexture(name: string): ImageTexture | undefined;
    // (undocumented)
    readonly mapView: MapView;
    updatePoiFromPoiTable(pointLabel: TextElement): boolean;
}

// @public
export class PoiTable {
    constructor(name: string, useAltNamesForKey: boolean);
    getEntry(poiName: string): PoiTableEntry | undefined;
    get isLoading(): boolean;
    load(poiTableUrl: string): Promise<boolean>;
    get loadedOk(): boolean;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly useAltNamesForKey: boolean;
}

// @public
export class PoiTableManager {
    constructor(mapView: MapView);
    addTable(poiTable: PoiTable): void;
    clear(): void;
    get finishedLoading(): boolean;
    getPoiTable(poiTableName: string | undefined): PoiTable | undefined;
    loadPoiTables(theme: Theme): Promise<void>;
    // (undocumented)
    readonly mapView: MapView;
    get poiTables(): Map<string, PoiTable>;
    }

// @public
export class PolarTileDataSource extends DataSource {
    constructor({ name, styleSetName, minDataLevel, maxDataLevel, minDisplayLevel, maxDisplayLevel, storageLevelOffset, geometryLevelOffset, debugTiles }: PolarTileDataSourceOptions);
    // @override (undocumented)
    canGetTile(zoomLevel: number, tileKey: TileKey): boolean;
    // (undocumented)
    createTechiqueEntry(kind: string): TechniqueEntry | undefined;
    // @override (undocumented)
    dispose(): void;
    // (undocumented)
    get geometryLevelOffset(): number;
    set geometryLevelOffset(geometryLevelOffset: number);
    // @override (undocumented)
    getTile(tileKey: TileKey): Tile;
    // @override (undocumented)
    getTilingScheme(): TilingScheme;
    // @override (undocumented)
    setStyleSet(styleSet?: StyleSet, definitions?: Definitions, languages?: string[]): void;
    // @override (undocumented)
    setTheme(theme: Theme, languages?: string[]): void;
    // @override (undocumented)
    shouldSubdivide(zoomLevel: number, tileKey: TileKey): boolean;
}

// @public (undocumented)
export interface PolarTileDataSourceOptions extends DataSourceOptions {
    debugTiles?: boolean;
    geometryLevelOffset?: number;
}

// @public
export interface RenderEvent extends THREE_2.Event {
    // (undocumented)
    time?: number;
    // (undocumented)
    type: MapViewEventNames.Render | MapViewEventNames.FirstFrame | MapViewEventNames.FrameComplete | MapViewEventNames.ThemeLoaded | MapViewEventNames.AnimationStarted | MapViewEventNames.AnimationFinished | MapViewEventNames.MovementStarted | MapViewEventNames.MovementFinished | MapViewEventNames.ContextLost | MapViewEventNames.ContextRestored | MapViewEventNames.CopyrightChanged;
}

// @public (undocumented)
export interface RequestHeaders {
    // (undocumented)
    [field: string]: string;
}

// @public
export enum ResourceComputationType {
    // (undocumented)
    EstimationInMb = 0,
    // (undocumented)
    NumberOfTiles = 1
}

// @public
export class RingBuffer<T> {
    constructor(capacity: number);
    asArray(): T[];
    get bottom(): T;
    // (undocumented)
    buffer: T[];
    // (undocumented)
    readonly capacity: number;
    clear(): void;
    deq(): T;
    enq(...data: T[]): void;
    enqOne(data: T): void;
    // (undocumented)
    head: number;
    iterator(): RingBuffer.Iterator<T>;
    // (undocumented)
    size: number;
    // (undocumented)
    tail: number;
    get top(): T;
}

// @public (undocumented)
export namespace RingBuffer {
    export class Iterator<T> {
        constructor(m_buffer: RingBuffer<T>, m_index?: number);
        next(): boolean;
        get value(): T;
    }
}

// @public
export class SampledTimer extends SimpleTimer {
    constructor(statistics: Statistics, name: string);
    getStats(): Stats | undefined;
    maxNumSamples: number;
    // (undocumented)
    readonly name: string;
    numResets: number;
    // @override
    reset(): void;
    samples: RingBuffer<number>;
    // @override
    setValue(val: number | undefined): void;
    // (undocumented)
    statistics: Statistics;
}

// @public
export function setDepthPrePassStencil(depthMesh: THREE_2.Mesh, colorMesh: THREE_2.Mesh): void;

// @public (undocumented)
export interface SimpleFrameStatistics {
    // (undocumented)
    appResults: Map<string, number>;
    // (undocumented)
    configs: Map<string, string>;
    // (undocumented)
    frames: Map<string, number | number[]>;
    // (undocumented)
    frameStats?: Map<string, Stats | undefined>;
    // (undocumented)
    messages: Array<string[] | undefined>;
    // (undocumented)
    zoomLevelData?: Map<string, number | number[]>;
    // (undocumented)
    zoomLevelLabels?: string[];
}

// @public
export class SimpleTimer implements Timer {
    constructor(statistics: Statistics, name: string);
    // (undocumented)
    readonly name: string;
    now(): number;
    reset(): void;
    running: boolean;
    setValue(val: number | undefined): void;
    start(): number;
    // (undocumented)
    statistics: Statistics;
    stop(): number;
    get value(): number | undefined;
}

// @public
export class Squares extends MapViewPoints {
    // @override (undocumented)
    testPoint(point: THREE_2.Vector3, screenPosition: THREE_2.Vector2, pickCoordinates: THREE_2.Vector2, index: number, distance: number, intersects: THREE_2.Intersection[]): void;
}

// @public
export class Statistics {
    constructor(name?: string | undefined, enabled?: boolean);
    addTimer(timer: Timer): Timer;
    createTimer(name: string, keepSamples?: boolean): Timer;
    // (undocumented)
    enabled: boolean;
    getTimer(name: string): Timer;
    hasTimer(name: string): boolean;
    log(header?: string, footer?: string): void;
    // (undocumented)
    name?: string | undefined;
    reset(): void;
    }

// @public
export interface Stats {
    avg: number;
    max: number;
    median: number;
    median75: number;
    median90: number;
    median95: number;
    median97: number;
    median99: number;
    median999: number;
    min: number;
    numSamples: number;
}

// @public
export class TextElement {
    constructor(text: string, points: THREE_2.Vector3[] | THREE_2.Vector3, renderParams: TextRenderParameters | TextRenderStyle, layoutParams: TextLayoutParameters | TextLayoutStyle, priority?: number, xOffset?: number, yOffset?: number, featureId?: number | undefined, style?: string | undefined, fadeNear?: number | undefined, fadeFar?: number | undefined, tileOffset?: number | undefined, offsetDirection?: number | undefined);
    alwaysOnTop?: boolean;
    bounds?: THREE_2.Box2;
    dbgPathTooSmall?: boolean;
    distanceScale: number;
    elevated: boolean;
    // (undocumented)
    fadeFar?: number | undefined;
    // (undocumented)
    fadeNear?: number | undefined;
    // (undocumented)
    featureId?: number | undefined;
    glyphCaseArray?: boolean[];
    glyphs?: GlyphData[];
    // (undocumented)
    hasFeatureId(): boolean;
    static readonly HIGHEST_PRIORITY: number;
    ignoreDistance?: boolean;
    kind?: GeometryKind | GeometryKindSet;
    // (undocumented)
    readonly layoutParams: TextLayoutParameters | TextLayoutStyle;
    // (undocumented)
    get layoutStyle(): TextLayoutStyle | undefined;
    set layoutStyle(style: TextLayoutStyle | undefined);
    loadingState?: LoadingState;
    maxZoomLevel?: number;
    mayOverlap?: boolean;
    minZoomLevel?: number;
    // (undocumented)
    readonly offsetDirection?: number | undefined;
    get path(): THREE_2.Vector3[] | undefined;
    // (undocumented)
    pathLengthSqr?: number;
    get poiInfo(): PoiInfo | undefined;
    set poiInfo(poiInfo: PoiInfo | undefined);
    // (undocumented)
    readonly points: THREE_2.Vector3[] | THREE_2.Vector3;
    get position(): THREE_2.Vector3;
    // (undocumented)
    priority: number;
    renderOrder?: number;
    // (undocumented)
    readonly renderParams: TextRenderParameters | TextRenderStyle;
    // (undocumented)
    get renderStyle(): TextRenderStyle | undefined;
    set renderStyle(style: TextRenderStyle | undefined);
    reserveSpace?: boolean;
    // (undocumented)
    style?: string | undefined;
    // (undocumented)
    readonly text: string;
    textBufferObject?: TextBufferObject;
    textFadeTime?: number;
    get textMayOverlap(): boolean;
    set textMayOverlap(mayOverlap: boolean);
    get textReservesSpace(): boolean;
    set textReservesSpace(reserveSpace: boolean);
    // (undocumented)
    readonly tileOffset?: number | undefined;
    // (undocumented)
    type: TextElementType;
    updateMinMaxZoomLevelsFromPoiInfo(): void;
    userData?: any;
    visible: boolean;
    // (undocumented)
    xOffset: number;
    // (undocumented)
    yOffset: number;
}

// @public (undocumented)
export interface TextElementIndex {
    // (undocumented)
    elementIndex: number;
    // (undocumented)
    groupIndex: number;
}

// @public
export class TextElementsRenderer {
    constructor(m_viewState: ViewState, m_viewCamera: THREE_2.Camera, m_viewUpdateCallback: ViewUpdateCallback, m_screenCollisions: ScreenCollisions, m_screenProjector: ScreenProjector, m_textCanvasFactory: TextCanvasFactory, m_poiManager: PoiManager, m_poiRendererFactory: PoiRendererFactory, m_fontCatalogLoader: FontCatalogLoader, m_theme: Theme, options: TextElementsRendererOptions);
    addOverlayText(textElements: TextElement[]): void;
    clearOverlayText(): void;
    clearRenderStates(): void;
    // (undocumented)
    get delayLabelsUntilMovementFinished(): boolean;
    set delayLabelsUntilMovementFinished(delay: boolean);
    set disableFading(disable: boolean);
    // (undocumented)
    get disableFading(): boolean;
    getMemoryUsage(): MapViewUtils.MemoryUsage;
    // (undocumented)
    hasOverlayText(): boolean;
    // (undocumented)
    get initialized(): boolean;
    // (undocumented)
    get initializing(): boolean;
    invalidateCache(): void;
    get loading(): boolean;
    movementFinished(): void;
    movementStarted(): void;
    // (undocumented)
    get overlayText(): TextElement[] | undefined;
    get overloaded(): boolean;
    pickTextElements(screenPosition: THREE_2.Vector2, pickResults: PickResult[]): void;
    placeText(dataSourceTileList: DataSourceTileList[], time: number): void;
    renderText(camera: THREE_2.OrthographicCamera): void;
    // (undocumented)
    get styleCache(): TextStyleCache;
    waitInitialized(): Promise<boolean>;
    waitLoaded(): Promise<boolean>;
}

// @public
export interface TextElementStyle {
    // (undocumented)
    fontCatalog: string;
    // (undocumented)
    layoutParams: TextLayoutParameters;
    // (undocumented)
    name: string;
    // (undocumented)
    poiRenderer?: PoiRenderer;
    // (undocumented)
    renderParams: TextRenderParameters;
    // (undocumented)
    textCanvas?: TextCanvas;
}

// @public (undocumented)
export interface TextPickResult extends PickResult {
    text?: string;
}

// @public (undocumented)
export class TextStyleCache {
    constructor(m_theme: Theme);
    createLayoutStyle(tile: Tile, technique: TextTechnique | PoiTechnique | LineMarkerTechnique): TextLayoutStyle;
    createRenderStyle(tile: Tile, technique: TextTechnique | PoiTechnique | LineMarkerTechnique): TextRenderStyle;
    getTextElementStyle(styleId?: string): TextElementStyle;
    // (undocumented)
    initializeDefaultTextElementStyle(defaultFontCatalogName: string): void;
    // (undocumented)
    initializeTextElementStyles(defaultPoiRenderer: PoiRenderer, defaultTextCanvas: TextCanvas, textRenderers: TextCanvasRenderer[]): void;
    }

// @public
export class TextureLoader {
    load(url: string, requestHeaders?: RequestHeaders | undefined, crossOrigin?: boolean): Promise<THREE_2.Texture>;
    }

// @public
export class ThemeLoader {
    static isThemeLoaded(theme: Theme_2 | FlatTheme): boolean;
    static load(theme: string | Theme_2 | FlatTheme, options?: ThemeLoadOptions): Promise<Theme_2>;
    // @deprecated (undocumented)
    static loadAsync(themeUrl: string): Promise<Theme_2>;
    }

// @public
export interface ThemeLoadOptions {
    logger?: ISimpleChannel;
    maxInheritanceDepth?: number;
    resolveDefinitions?: boolean;
    resolveIncludeUris?: boolean;
    resolveResourceUris?: boolean;
    signal?: AbortSignal;
    uriResolver?: UriResolver;
}

// @public
export class Tile implements CachedResource {
    constructor(dataSource: DataSource, tileKey: TileKey, offset?: number, localTangentSpace?: boolean);
    addBlockingElement(blockingElement: PathBlockingElement): void;
    addOwnedTexture(texture: THREE_2.Texture): void;
    addTextElement(textElement: TextElement): void;
    // @deprecated
    addUserTextElement(textElement: TextElement): void;
    get allGeometryLoaded(): boolean;
    get animatedExtrusionTileHandler(): AnimatedExtrusionTileHandler | undefined;
    set animatedExtrusionTileHandler(handler: AnimatedExtrusionTileHandler | undefined);
    get basicGeometryLoaded(): boolean;
    get blockingElements(): PathBlockingElement[];
    get boundingBox(): OrientedBox3;
    get center(): THREE_2.Vector3;
    clear(): void;
    clearTextElements(): void;
    computeWorldOffsetX(): number;
    copyrightInfo?: CopyrightInfo[];
    // (undocumented)
    readonly dataSource: DataSource;
    get decodedTile(): DecodedTile | undefined;
    set decodedTile(decodedTile: DecodedTile | undefined);
    readonly dependencies: string[];
    didRender(): void;
    dispose(): void;
    get disposed(): boolean;
    // @internal
    get elevationRange(): ElevationRange;
    set elevationRange(elevationRange: ElevationRange);
    forceHasGeometry(value: boolean | undefined): void;
    frameNumLastRequested: number;
    frameNumLastVisible: number;
    frameNumVisible: number;
    readonly geoBox: GeoBox;
    getResourceInfo(): TileResourceInfo;
    get hasGeometry(): boolean;
    hasTextElements(): boolean;
    invalidateResourceInfo(): void;
    get isVisible(): boolean;
    set isVisible(visible: boolean);
    levelOffset: number;
    load(): void;
    loadingFinished(): void;
    get localTangentSpace(): boolean;
    get mapView(): MapView;
    // (undocumented)
    get memoryUsage(): number;
    numFramesVisible: number;
    readonly objects: TileObject[];
    get offset(): number;
    set offset(offset: number);
    protected preparedTextPaths: TextPathGeometry[] | undefined;
    get projection(): Projection;
    removeDecodedTile(): void;
    removeTextElement(textElement: TextElement): boolean;
    // @deprecated
    removeUserTextElement(textElement: TextElement): boolean;
    resetVisibilityCounter(): void;
    shouldDisposeObjectGeometry(object: TileObject): boolean;
    shouldDisposeObjectMaterial(object: TileObject): boolean;
    shouldDisposeTexture(texture: THREE_2.Texture): boolean;
    skipRendering: boolean;
    // @internal
    get textElementGroups(): TextElementGroupPriorityList;
    get textElementsChanged(): boolean;
    set textElementsChanged(changed: boolean);
    get textStyleCache(): TileTextStyleCache;
    get tileGeometryLoader(): TileGeometryLoader | undefined;
    set tileGeometryLoader(tileGeometryLoader: TileGeometryLoader | undefined);
    // (undocumented)
    readonly tileKey: TileKey;
    get tileLoader(): ITileLoader | undefined;
    set tileLoader(tileLoader: ITileLoader | undefined);
    get uniqueKey(): number;
    update(zoomLevel: number): void;
    // @internal @deprecated (undocumented)
    get userTextElements(): TextElementGroup;
    visibilityCounter: number;
    get visibleArea(): number;
    set visibleArea(area: number);
    willRender(_zoomLevel: number): boolean;
}

// @public
export class TileDataAccessor {
    constructor(tile: Tile, visitor: ITileDataVisitor, options: TileDataAccessorOptions);
    protected getBufferGeometry(object: THREE_2.Mesh): THREE_2.BufferGeometry | undefined;
    protected getGeometryAccessor(geometryType: GeometryType, object: THREE_2.Mesh, bufferGeometry: THREE_2.BufferGeometry): IGeometryAccessor | undefined;
    protected getIndexedGeometryAccessor(geometryType: GeometryType, object: THREE_2.Mesh, bufferGeometry: THREE_2.BufferGeometry): IGeometryAccessor | undefined;
    // (undocumented)
    tile: Tile;
    visitAll(): void;
    protected visitMesh(meshObject: THREE_2.Mesh, featureData: TileFeatureData): void;
    protected visitObject(object: THREE_2.Object3D): void;
    }

// @public
export interface TileDataAccessorOptions {
    onlyWithFeatureIds?: boolean;
    wantsAll?: boolean;
    wantsAreas?: boolean;
    wantsLines?: boolean;
    wantsObject3D?: boolean;
    wantsPoints?: boolean;
}

// @public (undocumented)
export interface TileDisplacementMap {
    // (undocumented)
    displacementMap: DisplacementMap;
    // (undocumented)
    geoBox: GeoBox;
    // (undocumented)
    texture: THREE.DataTexture;
    // (undocumented)
    tileKey: TileKey;
}

// @public
export interface TileFeatureData {
    geometryType?: GeometryType;
    objInfos?: Array<{} | undefined>;
    starts?: number[];
}

// @public
export enum TileLoaderState {
    // (undocumented)
    Canceled = 5,
    // (undocumented)
    Decoding = 3,
    // (undocumented)
    Failed = 6,
    // (undocumented)
    Initialized = 0,
    // (undocumented)
    Loaded = 2,
    // (undocumented)
    Loading = 1,
    // (undocumented)
    Ready = 4
}

// @public (undocumented)
export type TileObject = THREE_2.Object3D & {
    displacement?: THREE_2.Vector3;
    _backupRenderOrder?: number;
};

// @public (undocumented)
export namespace TileOffsetUtils {
    export function extractOffsetAndMortonKeyFromKey(key: number, bitshift?: number): {
        offset: number;
        mortonCode: number;
    };
    export function getKeyForTileKeyAndOffset(tileKey: TileKey, offset: number, bitshift?: number): number;
    export function getParentKeyFromKey(calculatedKey: number, bitshift?: number): number;
}

// @public
export interface TileResourceInfo {
    gpuSize: number;
    heapSize: number;
    num3dObjects: number;
    numTextElements: number;
    // @deprecated (undocumented)
    numUserTextElements: number;
}

// @public
export interface TileResourceUsage {
    estimatedMemoryUsage: number;
    numColors: number;
    numGeometries: number;
    numMaterials: number;
    numObjects: number;
    numVertices: number;
}

// @public
export class TiltViewClipPlanesEvaluator extends TopViewClipPlanesEvaluator {
    // @override (undocumented)
    protected evaluateDistancePlanarProj(camera: THREE_2.Camera, projection: Projection, elevationProvider?: ElevationProvider): ViewRanges;
    // @override (undocumented)
    protected evaluateDistanceSphericalProj(camera: THREE_2.Camera, projection: Projection, elevationProvider?: ElevationProvider): ViewRanges;
    protected getFrustumGroundIntersectionDist(camera: THREE_2.Camera, projection: Projection): {
        top: number;
        bottom: number;
    };
    // (undocumented)
    protected getTiltedFovBasedFarPlane(d: number, r: number, halfFovAngle: number, cameraPitch: number): number;
}

// @public
export interface Timer {
    // (undocumented)
    readonly name: string;
    now(): number;
    reset(): void;
    setValue(val: number | undefined): void;
    start(): number;
    stop(): number;
    // (undocumented)
    readonly value?: number;
}

// @public
export class TopViewClipPlanesEvaluator extends ElevationBasedClipPlanesEvaluator {
    constructor(maxElevation?: number, minElevation?: number, nearMin?: number, nearFarMarginRatio?: number, farMaxRatio?: number);
    // @override (undocumented)
    evaluateClipPlanes(camera: THREE_2.Camera, projection: Projection, elevationProvider?: ElevationProvider): ViewRanges;
    // (undocumented)
    protected evaluateDistancePlanarProj(camera: THREE_2.Camera, projection: Projection, elevationProvider?: ElevationProvider): ViewRanges;
    // (undocumented)
    protected evaluateDistanceSphericalProj(camera: THREE_2.Camera, projection: Projection, elevationProvider?: ElevationProvider): ViewRanges;
    // (undocumented)
    readonly farMaxRatio: number;
    protected getCameraAltitude(camera: THREE_2.Camera, projection: Projection): number;
    // (undocumented)
    protected getFovBasedFarPlane(camera: THREE_2.PerspectiveCamera, d: number, r: number, fovAngle: number, projection: Projection): number;
    // (undocumented)
    protected getOrthoBasedFarPlane(d: number, r: number): number;
    protected getTangentBasedFarPlane(camera: THREE_2.PerspectiveCamera, d: number, r: number, alpha: number): number;
    protected getTangentDistance(d: number, r: number): number;
    protected m_tmpQuaternion: THREE_2.Quaternion;
    protected m_tmpVectors: THREE_2.Vector3[];
    protected get minimumViewRange(): ViewRanges;
    // (undocumented)
    readonly nearFarMarginRatio: number;
    // (undocumented)
    readonly nearMin: number;
}

// @public
export class UrlCopyrightProvider extends CopyrightCoverageProvider {
    constructor(m_fetchURL: string, m_baseScheme: string, m_requestHeaders?: RequestHeaders_2 | undefined, m_transferManager?: ITransferManager);
    // @override (undocumented)
    getCopyrightCoverageData(): Promise<AreaCopyrightInfo[]>;
    setRequestHeaders(headers: RequestHeaders_2 | undefined): void;
}

// @public
export function usesObject3D(technique: Technique): boolean;

// @public (undocumented)
export type ViewUpdateCallback = () => void;

// @public
export class VisibleTileSet {
    constructor(m_frustumIntersection: FrustumIntersection, m_tileGeometryManager: TileGeometryManager, options: VisibleTileSetOptions);
    // (undocumented)
    allVisibleTilesLoaded: boolean;
    clearTileCache(dataSource?: DataSource): void;
    // (undocumented)
    dataSourceTileList: DataSourceTileList[];
    disposePendingTiles(): void;
    disposeTile(tile: Tile): void;
    forEachCachedTile(fun: (tile: Tile) => void, dataSource?: DataSource): void;
    forEachVisibleTile(fun: (tile: Tile) => void): void;
    getCachedTile(dataSource: DataSource, tileKey: TileKey, offset?: number): Tile | undefined;
    getDataSourceCacheSize(): number;
    getNumberOfVisibleTiles(): number;
    getRenderedTile(dataSource: DataSource, tileKey: TileKey, offset?: number): Tile | undefined;
    getRenderedTileAtLocation(dataSource: DataSource, geoPoint: GeoCoordinates, offset?: number): Tile | undefined;
    getTile(dataSource: DataSource, tileKey: TileKey, offset?: number): Tile | undefined;
    markTilesDirty(dataSource?: DataSource): void;
    // (undocumented)
    options: VisibleTileSetOptions;
    removeDataSource(dataSource: DataSource): void;
    get resourceComputationType(): ResourceComputationType;
    set resourceComputationType(computationType: ResourceComputationType);
    setDataSourceCacheSize(size: number, computationType?: ResourceComputationType): void;
    setNumberOfVisibleTiles(size: number): void;
    updateClipPlanes(maxElevation?: number, minElevation?: number): ViewRanges;
    updateRenderList(storageLevel: number, zoomLevel: number, dataSources: DataSource[], elevationRangeSource?: ElevationRangeSource): {
        viewRanges: ViewRanges;
        viewRangesChanged: boolean;
    };
}

// @public
export interface VisibleTileSetOptions {
    clipPlanesEvaluator: ClipPlanesEvaluator;
    extendedFrustumCulling: boolean;
    maxVisibleDataSourceTiles: number;
    projection: Projection;
    quadTreeSearchDistanceDown: number;
    quadTreeSearchDistanceUp: number;
    resourceComputationType: ResourceComputationType;
    tileCacheSize: number;
}

// @public
export class WorkerBasedDecoder implements ITileDecoder {
    constructor(workerSet: ConcurrentWorkerSet, decoderServiceType: string);
    configure(styleSet?: StyleSet, definitions?: Definitions, languages?: string[], options?: OptionsMap): void;
    connect(): Promise<void>;
    decodeTile(data: ArrayBufferLike, tileKey: TileKey, projection: Projection, requestController?: RequestController): Promise<DecodedTile>;
    dispose(): void;
    getTileInfo(data: ArrayBufferLike, tileKey: TileKey, projection: Projection, requestController?: RequestController): Promise<TileInfo | undefined>;
    get workerCount(): number | undefined;
    }

// @public
export class WorkerBasedTiler implements ITiler {
    constructor(workerSet: ConcurrentWorkerSet, tilerServiceType: string);
    connect(): Promise<void>;
    dispose(): void;
    getTile(indexId: string, tileKey: TileKey): Promise<{}>;
    registerIndex(indexId: string, input: URL | GeoJson): Promise<void>;
    updateIndex(indexId: string, input: URL | GeoJson): Promise<void>;
    }

// @public
export class WorkerLoader {
    // (undocumented)
    static dependencyUrlMapping: {
        [name: string]: string;
    };
    // (undocumented)
    static directlyFallbackToBlobBasedLoading: boolean;
    static fetchScriptSourceToBlobUrl(scriptUrl: string): Promise<string>;
    // (undocumented)
    static sourceLoaderCache: Map<string, Promise<string>>;
    static startWorker(scriptUrl: string, timeout?: number): Promise<Worker>;
    static startWorkerBlob(scriptUrl: string, timeout: number): Promise<Worker>;
    static startWorkerImmediately(scriptUrl: string, timeout: number): Promise<Worker>;
    static waitWorkerInitialized(worker: Worker, timeout: number): Promise<Worker>;
}

// @internal
export type WorldAnchor<T extends THREE_2.Object3D = THREE_2.Object3D> = T & {
    worldPosition?: THREE_2.Vector3;
    pickable?: boolean;
};


```
