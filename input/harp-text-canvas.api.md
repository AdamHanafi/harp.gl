## API Report File for "@here/harp-text-canvas"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import * as THREE_2 from 'three';

// @public
export interface AdditionParameters {
    layer?: number;
    letterCaseArray?: boolean[];
    path?: THREE_2.Path | THREE_2.CurvePath<THREE_2.Vector2>;
    pathOverflow?: boolean;
    pickingData?: any;
    updatePosition?: boolean;
}

// @public
export class ContextualArabicConverter {
    convert(input: string): string;
    // (undocumented)
    static get instance(): ContextualArabicConverter;
    }

// @public
export function createSdfTextMaterial(params: SdfTextMaterialParameters): SdfTextMaterial;

// @public
export const DEFAULT_TEXT_CANVAS_LAYER = 0;

// @public
export namespace DefaultTextStyle {
    const // (undocumented)
    DEFAULT_FONT_NAME: string;
    const // (undocumented)
    DEFAULT_FONT_SIZE: FontSize;
    const // (undocumented)
    DEFAULT_FONT_STYLE: FontStyle;
    const // (undocumented)
    DEFAULT_FONT_VARIANT: FontVariant;
    const // (undocumented)
    DEFAULT_ROTATION: number;
    const // (undocumented)
    DEFAULT_COLOR: THREE_2.Color;
    const // (undocumented)
    DEFAULT_OPACITY: number;
    const // (undocumented)
    DEFAULT_BACKGROUND_COLOR: THREE_2.Color;
    const // (undocumented)
    DEFAULT_BACKGROUND_OPACITY: number;
    const // (undocumented)
    DEFAULT_TRACKING: number;
    const // (undocumented)
    DEFAULT_LEADING: number;
    const // (undocumented)
    DEFAULT_MAX_LINES: number;
    const // (undocumented)
    DEFAULT_LINE_WIDTH: number;
    const // (undocumented)
    DEFAULT_CANVAS_ROTATION: number;
    const // (undocumented)
    DEFAULT_LINE_ROTATION: number;
    const // (undocumented)
    DEFAULT_WRAPPING_MODE: WrappingMode;
    const // (undocumented)
    DEFAULT_VERTICAL_ALIGNMENT: VerticalAlignment;
    const // (undocumented)
    DEFAULT_HORIZONTAL_ALIGNMENT: HorizontalAlignment;
    const // (undocumented)
    DEFAULT_PLACEMENTS: TextPlacement[];
}

// @public
export interface Font {
    // (undocumented)
    bold?: string;
    // (undocumented)
    boldItalic?: string;
    // (undocumented)
    charset: string;
    // (undocumented)
    italic?: string;
    // (undocumented)
    metrics: FontMetrics;
    // (undocumented)
    name: string;
}

// @public
export class FontCatalog {
    clear(): void;
    dispose(): void;
    // (undocumented)
    readonly distanceRange: number;
    // (undocumented)
    readonly fonts: Font[];
    getFont(codePoint: number, fontName?: string): Font;
    getGlyph(codePoint: number, font: Font, fontStyle: FontStyle): GlyphData | undefined;
    getGlyphs(input: string, style: TextRenderStyle, letterCaseArray?: boolean[]): GlyphData[] | undefined;
    get isLoading(): boolean;
    static load(path: string, maxCodePointCount: number): Promise<FontCatalog>;
    loadBlock(block: UnicodeBlock, font: Font, fontStyle: FontStyle, loadPages?: boolean): Promise<any>;
    loadCharset(input: string, style: TextRenderStyle): Promise<GlyphData[]>;
    // (undocumented)
    static loadJSON(url: string): Promise<any>;
    // (undocumented)
    static loadTexture(url: string): Promise<THREE_2.Texture>;
    // (undocumented)
    readonly maxCodePointCount: number;
    // (undocumented)
    readonly maxHeight: number;
    // (undocumented)
    readonly maxWidth: number;
    // (undocumented)
    readonly name: string;
    removeBlock(block: UnicodeBlock, font: Font, fontStyle: FontStyle): void;
    // (undocumented)
    readonly size: number;
    get texture(): THREE_2.Texture;
    get textureSize(): THREE_2.Vector2;
    // (undocumented)
    readonly type: string;
    // (undocumented)
    readonly unicodeBlocks: UnicodeBlock[];
    update(renderer: THREE_2.WebGLRenderer): void;
    updateMemoryUsage(info: MemoryUsage): void;
    // (undocumented)
    readonly url: string;
}

// @public
export interface FontMetrics {
    // (undocumented)
    base: number;
    // (undocumented)
    capHeight: number;
    // (undocumented)
    distanceRange: number;
    // (undocumented)
    lineGap: number;
    // (undocumented)
    lineHeight: number;
    // (undocumented)
    size: number;
    // (undocumented)
    xHeight: number;
}

// @public
export interface FontSize {
    // (undocumented)
    backgroundSize: number;
    // (undocumented)
    size: number;
    // (undocumented)
    unit: FontUnit;
}

// @public
export enum FontStyle {
    // (undocumented)
    Bold = 1,
    // (undocumented)
    BoldItalic = 3,
    // (undocumented)
    Italic = 2,
    // (undocumented)
    Regular = 0
}

// @public
export enum FontUnit {
    // (undocumented)
    Em = 0,
    // (undocumented)
    Percent = 3,
    // (undocumented)
    Pixel = 1,
    // (undocumented)
    Point = 2
}

// @public
export enum FontVariant {
    // (undocumented)
    AllCaps = 1,
    // (undocumented)
    Regular = 0,
    // (undocumented)
    SmallCaps = 2
}

// @public
export class GlyphData {
    constructor(codePoint: number, block: string, width: number, height: number, advanceX: number, offsetX: number, offsetY: number, u0: number, v0: number, u1: number, v1: number, texture: THREE_2.Texture, font: Font);
    // (undocumented)
    readonly advanceX: number;
    // (undocumented)
    readonly block: string;
    readonly character: string;
    clone(): GlyphData;
    // (undocumented)
    readonly codePoint: number;
    copyIndex: number;
    readonly direction: UnicodeUtils.Direction;
    dynamicTextureCoordinates: THREE_2.Vector2[];
    // (undocumented)
    readonly font: Font;
    // (undocumented)
    readonly height: number;
    isInCache: boolean;
    // (undocumented)
    readonly offsetX: number;
    // (undocumented)
    readonly offsetY: number;
    positions: THREE_2.Vector3[];
    sourceTextureCoordinates: THREE_2.Vector2[];
    // (undocumented)
    readonly texture: THREE_2.Texture;
    // (undocumented)
    readonly width: number;
}

// @internal
export function hAlignFromPlacement(hP: HorizontalPlacement): HorizontalAlignment;

// @public
export enum HorizontalAlignment {
    // (undocumented)
    Center = -0.5,
    // (undocumented)
    Left = 0,
    // (undocumented)
    Right = -1
}

// @public
export enum HorizontalPlacement {
    // (undocumented)
    Center = -0.5,
    // (undocumented)
    Left = -1,
    // (undocumented)
    Right = 0
}

// @internal
export function hPlacementFromAlignment(hA: HorizontalAlignment): HorizontalPlacement;

// @public
export interface MeasurementParameters {
    letterCaseArray?: boolean[];
    outputCharacterBounds?: THREE_2.Box2[];
    path?: THREE_2.Path | THREE_2.CurvePath<THREE_2.Vector2>;
    pathOverflow?: boolean;
}

// @public
export interface MemoryUsage {
    // (undocumented)
    gpuSize: number;
    // (undocumented)
    heapSize: number;
}

// @internal
export function resolvePlacementAndAlignment(hAlignment?: HorizontalAlignment, vAlignment?: VerticalAlignment, placementsOpt?: TextPlacements): {
    horizontalAlignment: HorizontalAlignment;
    verticalAlignment: VerticalAlignment;
    placements: TextPlacements;
};

// @public
export interface SdfTextMaterialParameters {
    // (undocumented)
    fontCatalog: FontCatalog;
    // (undocumented)
    fragmentSource?: string;
    // (undocumented)
    isBackground?: boolean;
    // (undocumented)
    vertexSource?: string;
}

// @public
export interface TextBufferAdditionParameters {
    // (undocumented)
    backgroundColor?: THREE_2.Color;
    // (undocumented)
    backgroundOpacity?: number;
    // (undocumented)
    color?: THREE_2.Color;
    // (undocumented)
    layer?: number;
    // (undocumented)
    opacity?: number;
    // (undocumented)
    pickingData?: any;
    // (undocumented)
    position?: THREE_2.Vector3;
    // (undocumented)
    rotation?: number;
    // (undocumented)
    scale?: number;
}

// @public
export interface TextBufferCreationParameters {
    letterCaseArray?: boolean[];
    outputBounds?: boolean;
    outputCharacterBounds?: boolean;
    path?: THREE_2.Path | THREE_2.CurvePath<THREE_2.Vector2>;
    pathOverflow?: boolean;
    storeStyles?: boolean;
}

// @public
export class TextBufferObject {
    constructor(glyphs: GlyphData[], buffer: Float32Array, bounds?: THREE_2.Box2 | undefined, characterBounds?: THREE_2.Box2[] | undefined, textRenderStyle?: TextRenderStyle | undefined, textLayoutStyle?: TextLayoutStyle | undefined);
    // (undocumented)
    readonly bounds?: THREE_2.Box2 | undefined;
    // (undocumented)
    readonly buffer: Float32Array;
    // (undocumented)
    readonly characterBounds?: THREE_2.Box2[] | undefined;
    // (undocumented)
    readonly glyphs: GlyphData[];
    // (undocumented)
    readonly textLayoutStyle?: TextLayoutStyle | undefined;
    // (undocumented)
    readonly textRenderStyle?: TextRenderStyle | undefined;
}

// @public
export class TextCanvas {
    constructor(params: TextCanvasParameters);
    addLayer(layerId: number): TextCanvasLayer;
    addText(text: string | GlyphData[], position: THREE_2.Vector3, params?: AdditionParameters): boolean;
    addTextBufferObject(textBufferObject: TextBufferObject, params?: TextBufferAdditionParameters): boolean;
    get backgroundMaterial(): THREE_2.Material;
    set backgroundMaterial(value: THREE_2.Material);
    clear(): void;
    createTextBufferObject(text: string | GlyphData[], params?: TextBufferCreationParameters): TextBufferObject | undefined;
    get fontCatalog(): FontCatalog;
    set fontCatalog(value: FontCatalog);
    getAllLayers(): TextCanvasLayer[];
    getLayer(layerId: number): TextCanvasLayer | undefined;
    getMemoryUsage(info: MemoryUsage): void;
    get material(): THREE_2.Material;
    set material(value: THREE_2.Material);
    readonly maxGlyphCount: number;
    measureText(text: string | GlyphData[], outputBounds: THREE_2.Box2, params?: MeasurementParameters): boolean;
    readonly minGlyphCount: number;
    pickText(position: THREE_2.Vector2, callback: (pickData: any | undefined) => void): void;
    render(camera: THREE_2.OrthographicCamera, target?: THREE_2.WebGLRenderTarget, clear?: boolean): void;
    get textLayoutStyle(): TextLayoutStyle;
    set textLayoutStyle(style: TextLayoutStyle);
    get textRenderStyle(): TextRenderStyle;
    set textRenderStyle(style: TextRenderStyle);
}

// @public
export interface TextCanvasLayer {
    // (undocumented)
    id: number;
    // (undocumented)
    storage: TextGeometry;
}

// @public
export interface TextCanvasParameters {
    backgroundMaterial?: THREE_2.Material;
    fontCatalog: FontCatalog;
    material?: THREE_2.Material;
    maxGlyphCount: number;
    minGlyphCount: number;
    renderer: THREE_2.WebGLRenderer;
}

// @public
export interface TextLayoutParameters {
    // (undocumented)
    canvasRotation?: number;
    // (undocumented)
    horizontalAlignment?: HorizontalAlignment;
    // (undocumented)
    leading?: number;
    // (undocumented)
    lineRotation?: number;
    // (undocumented)
    lineWidth?: number;
    // (undocumented)
    maxLines?: number;
    // (undocumented)
    placements?: TextPlacements;
    // (undocumented)
    tracking?: number;
    // (undocumented)
    verticalAlignment?: VerticalAlignment;
    // (undocumented)
    wrappingMode?: WrappingMode;
}

// @public
export class TextLayoutStyle {
    constructor(params?: TextLayoutParameters);
    get canvasRotation(): number;
    set canvasRotation(value: number);
    clone(params?: TextLayoutParameters): TextLayoutStyle;
    copy(other: TextLayoutStyle): TextLayoutStyle;
    get horizontalAlignment(): HorizontalAlignment;
    set horizontalAlignment(value: HorizontalAlignment);
    get leading(): number;
    set leading(value: number);
    get lineRotation(): number;
    set lineRotation(value: number);
    get lineWidth(): number;
    set lineWidth(value: number);
    get maxLines(): number;
    set maxLines(value: number);
    get params(): TextLayoutParameters;
    set params(value: TextLayoutParameters);
    get placements(): TextPlacements;
    set placements(value: TextPlacements);
    get tracking(): number;
    set tracking(value: number);
    get verticalAlignment(): VerticalAlignment;
    set verticalAlignment(value: VerticalAlignment);
    get wrappingMode(): WrappingMode;
    set wrappingMode(value: WrappingMode);
}

// @public (undocumented)
export interface TextPlacement {
    // (undocumented)
    h: HorizontalPlacement;
    // (undocumented)
    v: VerticalPlacement;
}

// @public (undocumented)
export type TextPlacements = TextPlacement[];

// @public
export interface TextRenderParameters {
    // (undocumented)
    backgroundColor?: THREE_2.Color;
    // (undocumented)
    backgroundOpacity?: number;
    // (undocumented)
    color?: THREE_2.Color;
    // (undocumented)
    fontName?: string;
    // (undocumented)
    fontSize?: FontSize;
    // (undocumented)
    fontStyle?: FontStyle;
    // (undocumented)
    fontVariant?: FontVariant;
    // (undocumented)
    opacity?: number;
    // (undocumented)
    rotation?: number;
}

// @public
export class TextRenderStyle {
    constructor(params?: TextRenderParameters);
    get backgroundColor(): THREE_2.Color;
    set backgroundColor(value: THREE_2.Color);
    get backgroundOpacity(): number;
    set backgroundOpacity(value: number);
    clone(params?: TextRenderParameters): TextRenderStyle;
    get color(): THREE_2.Color;
    set color(value: THREE_2.Color);
    copy(source: TextRenderStyle): TextRenderStyle;
    get fontName(): string;
    set fontName(value: string);
    get fontSize(): FontSize;
    set fontSize(value: FontSize);
    get fontStyle(): FontStyle;
    set fontStyle(value: FontStyle);
    get fontVariant(): FontVariant;
    set fontVariant(value: FontVariant);
    get opacity(): number;
    set opacity(value: number);
    get params(): TextRenderParameters;
    set params(value: TextRenderParameters);
    get rotation(): number;
    set rotation(value: number);
}

// @public
export namespace TypesettingUtils {
    const EM_TO_PX = 16;
    const PT_TO_PX = 1.25;
    const OBLIQUE_ANGLE = 0.174533;
    const OBLIQUE_OFFSET: number;
    export function computeGlyphTransform(transform: THREE_2.Matrix3, position: THREE_2.Vector3, scale: number, rotation: number, localRotation: number): void;
    export function getDirection(glyphs: GlyphData[], offset: number): UnicodeUtils.Direction;
    export function getPixelSize(size: number, unit: FontUnit, originalSize: number): number;
    export function getSmallCapsScale(glyphs: GlyphData[], smallCapsTransformations: boolean[], index: number, fontVariant: FontVariant): number;
    export function updateBounds(corners: THREE_2.Vector3[], globalBounds: THREE_2.Box2, individualBounds?: {
        array: THREE_2.Box2[];
        offset: number;
    }): void;
}

// @public
export interface UnicodeBlock {
    // (undocumented)
    fonts: string[];
    // (undocumented)
    max: number;
    // (undocumented)
    min: number;
    // (undocumented)
    name: string;
}

// @public
export namespace UnicodeUtils {
    const whiteSpaceRanges: number[][];
    export enum Direction {
        // (undocumented)
        LTR = 1,
        // (undocumented)
        Neutral = 0,
        // (undocumented)
        RTL = -1,
        // (undocumented)
        Weak = 0.5
    }
    const newLineRanges: number[][];
    export function getDirection(codePoint: number, block: string): Direction;
    const nonPrintableRanges: number[][];
    export function isNewLine(codePoint: number): boolean;
    export function isPrintable(codePoint: number): boolean;
    const rtlBlocks: string[];
    const neutralBidirectionalRanges: number[][];
    const weakBidirectionalRanges: number[][];
    export function isRtlMirrored(codePoint: number): boolean;
    const rtlMirroredCodePoints: number[];
    export function isWhiteSpace(codePoint: number): boolean;
}

// @internal
export function vAlignFromPlacement(vP: VerticalPlacement): VerticalAlignment;

// @public
export enum VerticalAlignment {
    // (undocumented)
    Above = 0,
    // (undocumented)
    Below = -1,
    // (undocumented)
    Center = -0.5
}

// @public
export enum VerticalPlacement {
    // (undocumented)
    Bottom = -1,
    // (undocumented)
    Center = -0.5,
    // (undocumented)
    Top = 0
}

// @internal
export function vPlacementFromAlignment(vA: VerticalAlignment): VerticalPlacement;

// @public
export enum WrappingMode {
    // (undocumented)
    Character = 1,
    // (undocumented)
    None = 0,
    // (undocumented)
    Word = 2
}


```
