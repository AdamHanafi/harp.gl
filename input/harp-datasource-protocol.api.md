## API Report File for "@here/harp-datasource-protocol"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { OrientedBox3 } from '@here/harp-geoutils';
import { Projection } from '@here/harp-geoutils';
import { TileKey } from '@here/harp-geoutils';
import { Vector3Like } from '@here/harp-geoutils/lib/math/Vector3Like';
import { Vector3Like as Vector3Like_2 } from '@here/harp-geoutils';

// @public
export function addBuffersToTransferList(technique: Technique, transferList: ArrayBuffer[]): void;

// @public
export interface AmbientLight extends BaseLight {
    color: string;
    // (undocumented)
    intensity?: number;
    // (undocumented)
    type: "ambient";
}

// @public
export interface Attachment {
    edgeIndex?: BufferAttribute;
    groups: Group[];
    index?: BufferAttribute;
    name?: string;
    uuid?: string;
}

// @public
type Attr_2<T> = {
    [P in keyof T]?: T[P] | JsonExpr;
};

export { Attr_2 as Attr }

// @public
export type AttributeMap = {} | number;

// @public (undocumented)
export interface BaseLight {
    // (undocumented)
    name: string;
    // (undocumented)
    type: string;
}

// @public
export type BaseStyle<Technique, Params> = Partial<Params> & {
    description?: string;
    styleSet?: string;
    category?: string | JsonExpr;
    technique: Technique;
    renderOrder?: number | JsonExpr;
    minZoomLevel?: number | JsonExpr;
    maxZoomLevel?: number | JsonExpr;
    transient?: boolean;
    debug?: boolean;
    metricUnit?: "Meter" | "Pixel";
    labelProperty?: string;
    attr?: Partial<Params>;
};

// @public
export interface BaseTechniqueParams {
    category?: DynamicProperty<string>;
    enabled?: DynamicProperty<boolean>;
    fadeFar?: DynamicProperty<number>;
    fadeNear?: DynamicProperty<number>;
    id?: string;
    // @deprecated
    kind?: GeometryKind | GeometryKindSet;
    renderOrder?: DynamicProperty<number>;
    transient?: boolean;
}

// @public (undocumented)
export const baseTechniqueParamsDescriptor: TechniqueDescriptor<BaseTechniqueParams>;

// @public
export interface BaseValueDefinition {
    description?: string;
    type?: string;
}

// @public (undocumented)
export type BasicExtrudedLineStyle = BaseStyle<"extruded-line", BasicExtrudedLineTechniqueParams>;

// @public
export interface BasicExtrudedLineTechnique extends MakeTechniqueAttrs<BasicExtrudedLineTechniqueParams> {
    // (undocumented)
    name: "extruded-line";
}

// @public
export interface BasicExtrudedLineTechniqueParams extends BaseTechniqueParams, PolygonalTechniqueParams {
    caps?: DynamicProperty<"None" | "Circle">;
    color: DynamicProperty<StyleColor>;
    lineWidth: DynamicProperty<number>;
    opacity?: DynamicProperty<number>;
    shading?: "basic";
    transparent?: boolean;
    wireframe?: boolean;
}

// @public (undocumented)
export type BinaryOp = RelationalOp | EqualityOp;

// @public
export class BooleanLiteralExpr extends LiteralExpr {
    constructor(value: boolean);
    // @override (undocumented)
    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result;
    // (undocumented)
    readonly value: boolean;
}

// @public
export interface BoxedAnyDefinition extends BaseValueDefinition {
    value: LiteralValue | JsonExpr;
}

// @public
export interface BoxedBooleanDefinition extends BaseValueDefinition {
    type: "boolean";
    value: DynamicProperty<boolean>;
}

// @public
export interface BoxedColorDefinition extends BaseValueDefinition {
    type: "color";
    value: DynamicProperty<string>;
}

// @public
export type BoxedDefinition = BoxedAnyDefinition | BoxedBooleanDefinition | BoxedNumericDefinition | BoxedStringDefinition | BoxedColorDefinition | BoxedSelectorDefinition;

// @public
export interface BoxedNumericDefinition extends BaseValueDefinition {
    type: "number";
    value: DynamicProperty<number>;
}

// @public
export interface BoxedSelectorDefinition extends BaseValueDefinition {
    type: "selector";
    value: string | JsonExpr;
}

// @public
export interface BoxedStringDefinition extends BaseValueDefinition {
    type: "string";
    value: DynamicProperty<string>;
}

// @public
export interface BufferAttribute {
    // (undocumented)
    buffer: ArrayBufferLike;
    // (undocumented)
    itemCount: number;
    // (undocumented)
    name: string;
    // (undocumented)
    normalized?: boolean;
    // (undocumented)
    type: BufferElementType;
}

// @public
export type BufferElementType = "float" | "uint8" | "uint16" | "uint32" | "int8" | "int16" | "int32";

// @public (undocumented)
export class CallExpr extends Expr {
    constructor(op: string, args: Expr[]);
    // @override (undocumented)
    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result;
    // (undocumented)
    readonly args: Expr[];
    // @deprecated
    get children(): Expr[];
    // (undocumented)
    descriptor?: OperatorDescriptor;
    // @override (undocumented)
    protected exprIsDynamic(): boolean;
    // (undocumented)
    readonly op: string;
}

// @public (undocumented)
export class CaseExpr extends Expr {
    constructor(branches: Array<[Expr, Expr]>, fallback: Expr);
    // @override (undocumented)
    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result;
    // (undocumented)
    readonly branches: Array<[Expr, Expr]>;
    // @override (undocumented)
    protected exprIsDynamic(): boolean;
    // (undocumented)
    readonly fallback: Expr;
}

// @public
export type CirclesStyle = BaseStyle<"circles", PointTechniqueParams>;

// @public
export interface CirclesTechnique extends MakeTechniqueAttrs<PointTechniqueParams> {
    // (undocumented)
    name: "circles";
}

// @public (undocumented)
export const circlesTechniquePropTypes: TechniqueDescriptor<CirclesTechnique>;

// @public
export namespace ColorUtils {
    export function getAlphaFromHex(hex: number): number;
    export function getHexFromHsl(h: number, s: number, l: number): number;
    export function getHexFromRgb(r: number, g: number, b: number): number;
    export function getHexFromRgba(r: number, g: number, b: number, a: number): number;
    export function getRgbaFromHex(hex: number, target?: RGBA): RGBA;
    export function hasAlphaInHex(hex: number): boolean;
    export function removeAlphaFromHex(hex: number): number;
}

// @public
export function composeTechniqueTextureName(imageName: string, technique: PoiTechnique | LineMarkerTechnique): string;

// @public
export interface CubemapSky {
    negativeX: string;
    negativeY: string;
    negativeZ: string;
    positiveX: string;
    positiveY: string;
    positiveZ: string;
    type: "cubemap";
}

// @public
export interface DataTextureProperties {
    // (undocumented)
    format?: PixelFormat;
    // (undocumented)
    height: number;
    // (undocumented)
    type?: TextureDataType;
    // (undocumented)
    width: number;
}

// @public
export interface DecodedTile {
    boundingBox?: OrientedBox3;
    copyrightHolderIds?: string[];
    // (undocumented)
    decodeTime?: number;
    // (undocumented)
    geometries: Geometry[];
    maxGeometryHeight?: number;
    // (undocumented)
    pathGeometries?: PathGeometry[];
    // (undocumented)
    poiGeometries?: PoiGeometry[];
    // (undocumented)
    techniques: IndexedTechnique[];
    // (undocumented)
    textGeometries?: TextGeometry[];
    // (undocumented)
    textPathGeometries?: TextPathGeometry[];
    // (undocumented)
    tileInfo?: TileInfo;
}

// @public
export type Definition = LiteralValue | JsonExpr | BoxedDefinition | StyleDeclaration;

// @public
export interface Definitions {
    // (undocumented)
    [name: string]: Definition;
}

// @public
export interface DirectionalLight extends BaseLight {
    // (undocumented)
    castShadow?: boolean;
    color: string;
    // (undocumented)
    direction: Vector3Like;
    // (undocumented)
    intensity: number;
    // (undocumented)
    type: "directional";
}

// @public
export type DynamicProperty<T> = T | JsonExpr | InterpolatedPropertyDefinition<T>;

// @public (undocumented)
export class Env {
    static isEnv(object: any): object is Env;
    lookup(_name: string): Value | undefined;
    unmap(): ValueMap;
}

// @public (undocumented)
export type EqualityOp = "~=" | "^=" | "$=" | "==" | "!=";

// @public
export abstract class Expr {
    // (undocumented)
    abstract accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result;
    dependencies(): ExprDependencies;
    evaluate(env: Env, scope?: ExprScope, cache?: Map<Expr, Value>): Value | never;
    protected abstract exprIsDynamic(): boolean;
    static fromJSON(node: JsonValue, definitions?: Definitions, definitionExprCache?: Map<string, Expr>): Expr;
    instantiate(context: InstantiationContext): Expr;
    intern(pool: ExprPool): Expr;
    isDynamic(): boolean;
    static isExpr(value: any): value is Expr;
    // @deprecated
    static parse(code: string): Expr | never;
    // (undocumented)
    toJSON(): JsonValue;
}

// @public
export class ExprDependencies {
    featureState?: boolean;
    readonly properties: Set<string>;
    volatile?: boolean;
}

// @public
export enum ExprScope {
    Condition = 1,
    Dynamic = 2,
    Value = 0
}

// @public (undocumented)
export interface ExprVisitor<Result, Context> {
    // (undocumented)
    visitBooleanLiteralExpr(expr: BooleanLiteralExpr, context: Context): Result;
    // (undocumented)
    visitCallExpr(expr: CallExpr, context: Context): Result;
    // (undocumented)
    visitCaseExpr(expr: CaseExpr, context: Context): Result;
    // (undocumented)
    visitHasAttributeExpr(expr: HasAttributeExpr, context: Context): Result;
    // (undocumented)
    visitInterpolateExpr(expr: InterpolateExpr, context: Context): Result;
    // (undocumented)
    visitMatchExpr(expr: MatchExpr, context: Context): Result;
    // (undocumented)
    visitNullLiteralExpr(expr: NullLiteralExpr, context: Context): Result;
    // (undocumented)
    visitNumberLiteralExpr(expr: NumberLiteralExpr, context: Context): Result;
    // (undocumented)
    visitObjectLiteralExpr(expr: ObjectLiteralExpr, context: Context): Result;
    // (undocumented)
    visitStepExpr(expr: StepExpr, context: Context): Result;
    // (undocumented)
    visitStringLiteralExpr(expr: StringLiteralExpr, context: Context): Result;
    // (undocumented)
    visitVarExpr(expr: VarExpr, context: Context): Result;
}

// @public
export type ExtrudedPolygonStyle = BaseStyle<"extruded-polygon", ExtrudedPolygonTechniqueParams>;

// @public
export interface ExtrudedPolygonTechnique extends MakeTechniqueAttrs<ExtrudedPolygonTechniqueParams> {
    // (undocumented)
    name: "extruded-polygon";
}

// @public
export interface ExtrudedPolygonTechniqueParams extends StandardTechniqueParams {
    animateExtrusion?: DynamicProperty<boolean>;
    animateExtrusionDuration?: number;
    boundaryWalls?: boolean;
    constantHeight?: boolean;
    defaultColor?: DynamicProperty<StyleColor>;
    // @deprecated
    defaultHeight?: number;
    enableDepthPrePass?: boolean;
    floorHeight?: DynamicProperty<number>;
    footprint?: boolean;
    height?: DynamicProperty<number>;
    lineColor?: DynamicProperty<StyleColor>;
    lineColorMix?: number;
    lineFadeFar?: DynamicProperty<number>;
    lineFadeNear?: DynamicProperty<number>;
    lineWidth: DynamicProperty<number>;
    maxSlope?: number;
}

// @public
export interface Feature {
    // (undocumented)
    bbox?: number[];
    // (undocumented)
    geometry: FeatureGeometry | GeometryCollection;
    // (undocumented)
    id?: string;
    // (undocumented)
    properties?: any;
    // (undocumented)
    title?: string;
    // (undocumented)
    type: "Feature";
}

// @public
export interface FeatureCollection {
    // (undocumented)
    features: Feature[];
    // (undocumented)
    type: "FeatureCollection";
}

// @public
export interface FeatureDetails {
    // (undocumented)
    featureClass?: string;
    // (undocumented)
    featureId?: string;
}

// @public
export type FeatureGeometry = Point | MultiPoint | LineString | MultiLineString | Polygon | MultiPolygon;

// @public (undocumented)
export type FillStyle = BaseStyle<"fill", FillTechniqueParams>;

// @public
export interface FillTechnique extends MakeTechniqueAttrs<FillTechniqueParams> {
    // (undocumented)
    name: "fill";
}

// @public
export interface FillTechniqueParams extends BaseTechniqueParams, PolygonalTechniqueParams {
    color?: DynamicProperty<StyleColor>;
    lineWidth?: DynamicProperty<number>;
    opacity?: DynamicProperty<number>;
    transparent?: boolean;
    wireframe?: boolean;
}

// @internal
export type FlatTheme = Omit<Theme, "styles"> & {
    styles?: StyleSet;
};

// @public
export interface Fog {
    color: string;
    startRatio: number;
}

// @public
export interface FontCatalogConfig {
    // (undocumented)
    name: string;
    // (undocumented)
    url: string;
}

// @public
export type GeoJson = FeatureGeometry | GeometryCollection | Feature | FeatureCollection;

// @public
export interface Geometry {
    attachments?: Attachment[];
    // (undocumented)
    edgeIndex?: BufferAttribute;
    featureStarts?: number[];
    // (undocumented)
    groups: Group[];
    // (undocumented)
    index?: BufferAttribute;
    // (undocumented)
    interleavedVertexAttributes?: InterleavedBufferAttribute[];
    objInfos?: AttributeMap[];
    // (undocumented)
    type: GeometryType;
    // (undocumented)
    uuid?: string;
    // (undocumented)
    vertexAttributes?: BufferAttribute[];
}

// @public
export interface GeometryCollection {
    // (undocumented)
    geometries: FeatureGeometry[];
    // (undocumented)
    type: "GeometryCollection";
}

// @public
export type GeometryKind = string | StandardGeometryKind;

// @public (undocumented)
export const GeometryKind: typeof StandardGeometryKind;

// @public
export class GeometryKindSet extends Set {
    hasIntersection(set: any): boolean;
    hasOrIntersects(set: any): boolean;
    hasOrIntersectsArray(subset: any[]): boolean;
    isSuperset(subset: Set<any>): boolean;
}

// @public
export enum GeometryType {
    // (undocumented)
    ExtrudedLine = 6,
    // (undocumented)
    ExtrudedPolygon = 8,
    // (undocumented)
    Line = 2,
    // (undocumented)
    Object3D = 9,
    // (undocumented)
    Other = 1000,
    // (undocumented)
    Point = 1,
    // (undocumented)
    Polygon = 7,
    // (undocumented)
    SolidLine = 3,
    // (undocumented)
    Text = 4,
    // (undocumented)
    TextPath = 5,
    // (undocumented)
    Unspecified = 0
}

// @public
export function getArrayConstructor(attr: BufferElementType): Float32ArrayConstructor | Uint8ArrayConstructor | Uint16ArrayConstructor | Uint32ArrayConstructor | Int8ArrayConstructor | Int16ArrayConstructor | Int32ArrayConstructor;

// @public (undocumented)
export function getFeatureId(attributeMap: AttributeMap | undefined): number;

// @public
export function getFeatureName(env: Env, basePropName: string | undefined, useAbbreviation?: boolean, useIsoCode?: boolean, languages?: string[]): string | undefined;

// @public
export function getFeatureText(context: Env | AttrEvaluationContext, technique: Technique, languages?: string[]): string | undefined;

// @public
export function getProjection(projectionName: string): Projection | never;

// @public
export function getProjectionName(projection: Projection): string | never;

// @public
export function getPropertyValue(property: Value | undefined, env: Env, cache?: Map<Expr, Value>): any;

// @public
export interface GradientSky {
    bottomColor: string;
    groundColor: string;
    monomialPower?: number;
    topColor: string;
    type: "gradient";
}

// @public
export interface Group {
    // (undocumented)
    count: number;
    createdOffsets?: number[];
    // (undocumented)
    start: number;
    // (undocumented)
    technique: number;
}

// @public
export class HasAttributeExpr extends Expr {
    constructor(name: string);
    // @override (undocumented)
    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result;
    // @override (undocumented)
    protected exprIsDynamic(): boolean;
    // (undocumented)
    readonly name: string;
}

// @public
export interface HeightBasedColors {
    // (undocumented)
    colorArray: string[];
    // (undocumented)
    heightArray: number[];
}

// @public (undocumented)
export interface IBloomEffect {
    // (undocumented)
    enabled: boolean;
    // (undocumented)
    radius: number;
    // (undocumented)
    strength: number;
    threshold: number;
}

// @public
export interface ImageDefinition {
    atlas?: string;
    preload: boolean;
    url: string;
}

// @public (undocumented)
export interface ImageDefinitions {
    [name: string]: ImageDefinition;
}

// @public
export interface ImageTexture {
    flipH?: boolean;
    flipV?: boolean;
    height?: number;
    image: string;
    name: string;
    opacity?: number;
    origin?: string;
    width?: number;
    xOffset?: number;
    yOffset?: number;
}

// @public
export type IndexedTechnique = Technique & IndexedTechniqueParams;

// @public
export interface IndexedTechniqueParams {
    _category?: string;
    _index: number;
    _kindState?: boolean;
    _secondaryCategory?: string;
    _styleSet?: string;
    _styleSetIndex: number;
    _usesFeatureState?: boolean;
}

// @public
export interface InterleavedBufferAttribute {
    // (undocumented)
    attributes: Array<{
        name: string;
        itemSize: number;
        offset: number;
    }>;
    // (undocumented)
    buffer: ArrayBufferLike;
    // (undocumented)
    stride: number;
    // (undocumented)
    type: BufferElementType;
}

// @public
export interface InterpolatedPropertyDefinition<T> {
    // (undocumented)
    exponent?: number;
    // (undocumented)
    interpolation?: "Discrete" | "Linear" | "Cubic" | "Exponential";
    // (undocumented)
    values: T[];
    // (undocumented)
    zoomLevels: number[];
}

// @public
export function interpolatedPropertyDefinitionToJsonExpr(property: InterpolatedPropertyDefinition<any>): JsonExpr;

// @public (undocumented)
export class InterpolateExpr extends Expr {
    constructor(mode: InterpolateMode, input: Expr, stops: Array<[number, Expr]>);
    // @override (undocumented)
    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result;
    // @override (undocumented)
    protected exprIsDynamic(): boolean;
    // (undocumented)
    readonly input: Expr;
    // (undocumented)
    readonly mode: InterpolateMode;
    // (undocumented)
    readonly stops: Array<[number, Expr]>;
}

// @public
export type InterpolateMode = ["discrete"] | ["linear"] | ["cubic"] | ["exponential", number];

// @public
export enum InterpolationMode {
    // (undocumented)
    Cubic = 2,
    // (undocumented)
    Discrete = 0,
    // (undocumented)
    Exponential = 3,
    // (undocumented)
    Linear = 1
}

// @public (undocumented)
export interface IOutlineEffect {
    // (undocumented)
    color: string;
    // (undocumented)
    enabled: boolean;
    ghostExtrudedPolygons: boolean;
    // (undocumented)
    thickness: number;
}

// @public (undocumented)
export function isActualSelectorDefinition(def: Definition): def is Style & StyleSelector;

// @public
export function isBasicExtrudedLineTechnique(technique: Technique): technique is BasicExtrudedLineTechnique;

// @public
export function isBoxedDefinition(def: Definition): def is BoxedDefinition;

// @public
export function isCirclesTechnique(technique: Technique): technique is CirclesTechnique;

// @public (undocumented)
export interface ISepiaEffect {
    // (undocumented)
    amount: number;
    // (undocumented)
    enabled: boolean;
}

// @public
export function isExtrudedLineTechnique(technique: Technique): technique is BasicExtrudedLineTechnique | StandardExtrudedLineTechnique;

// @public
export function isExtrudedPolygonTechnique(technique: Technique): technique is ExtrudedPolygonTechnique;

// @public
export function isFillTechnique(technique: Technique): technique is FillTechnique;

// @public
export function isInterpolatedPropertyDefinition<T>(p: any): p is InterpolatedPropertyDefinition<T>;

// @public (undocumented)
export function isJsonExpr(v: any): v is JsonExpr;

// @public
export function isJsonExprReference(value: any): value is JsonExprReference;

// @public (undocumented)
export function isLabelRejectionLineTechnique(technique: Technique): technique is LabelRejectionLineTechnique;

// @public
export function isLineMarkerTechnique(technique: Technique): technique is LineMarkerTechnique;

// @public
export function isLineTechnique(technique: Technique): technique is LineTechnique;

// @public (undocumented)
export function isLiteralDefinition(def: Definition): def is LiteralValue;

// @public
export function isPoiTechnique(technique: Technique): technique is PoiTechnique;

// @public
export function isSegmentsTechnique(technique: Technique): technique is SegmentsTechnique;

// @public
export function isShaderTechnique(technique: Technique): technique is ShaderTechnique;

// @public
export function isSolidLineTechnique(technique: Technique): technique is SolidLineTechnique;

// @public
export function isSpecialDashesLineTechnique(technique: Technique): technique is SolidLineTechnique;

// @public
export function isSquaresTechnique(technique: Technique): technique is SquaresTechnique;

// @public
export function isStandardExtrudedLineTechnique(technique: Technique): technique is StandardExtrudedLineTechnique;

// @public
export function isStandardTechnique(technique: Technique): technique is StandardTechnique;

// @public
export function isTerrainTechnique(technique: Technique): technique is TerrainTechnique;

// @public
export function isTextTechnique(technique: Technique): technique is TextTechnique;

// @public
export function isTextureBuffer(object: any): object is TextureBuffer;

// @public
export interface ITileDecoder {
    configure(styleSet?: StyleSet, definitions?: Definitions, languages?: string[], options?: OptionsMap): void;
    connect(): Promise<void>;
    decodeTile(data: ArrayBufferLike | {}, tileKey: TileKey, projection: Projection, requestController?: RequestController): Promise<DecodedTile>;
    dispose(): void;
    getTileInfo(data: ArrayBufferLike | {}, tileKey: TileKey, projection: Projection, requestController?: RequestController): Promise<TileInfo | undefined>;
}

// @public
export interface ITiler {
    connect(): Promise<void>;
    dispose(): void;
    getTile(indexId: string, tileKey: TileKey): Promise<{}>;
    registerIndex(indexId: string, indexUrl: URL | GeoJson): Promise<void>;
    updateIndex(indexId: string, indexUrl: URL | GeoJson): Promise<void>;
}

// @public (undocumented)
export interface IVignetteEffect {
    // (undocumented)
    darkness: number;
    // (undocumented)
    enabled: boolean;
    // (undocumented)
    offset: number;
}

// @public
export interface JsonArray extends Array<JsonValue> {
}

// @public
export type JsonExpr = JsonArray;

// @public (undocumented)
export type JsonExprReference = ["ref", string];

// @public
export interface JsonObject {
    // (undocumented)
    [name: string]: JsonValue;
}

// @public
export type JsonValue = null | boolean | number | string | JsonObject | JsonArray;

// @public (undocumented)
export type LabelRejectionLineStyle = BaseStyle<"label-rejection-line", BaseTechniqueParams>;

// @public
export interface LabelRejectionLineTechnique extends MakeTechniqueAttrs<BaseTechniqueParams> {
    // (undocumented)
    name: "label-rejection-line";
}

// @public
export type Light = AmbientLight | DirectionalLight;

// @public
export type LineCaps = "Square" | "Round" | "None" | "TriangleOut" | "TriangleIn";

// @public
export type LineDashes = "Square" | "Round" | "Diamond";

// @public
export type LineMarkerStyle = BaseStyle<"line-marker", MarkerTechniqueParams>;

// @public
export interface LineMarkerTechnique extends MakeTechniqueAttrs<MarkerTechniqueParams> {
    // (undocumented)
    name: "line-marker";
}

// @public
export interface LineString {
    // (undocumented)
    coordinates: number[][];
    // (undocumented)
    type: "LineString";
}

// @public
export type LineStyle = BaseStyle<"line", LineTechniqueParams>;

// @public
export interface LineTechnique extends MakeTechniqueAttrs<LineTechniqueParams> {
    // (undocumented)
    name: "line";
}

// @public (undocumented)
export const lineTechniqueDescriptor: TechniqueDescriptor<LineTechnique>;

// @public (undocumented)
export interface LineTechniqueParams extends BaseTechniqueParams {
    color: DynamicProperty<StyleColor>;
    lineWidth: DynamicProperty<number>;
    opacity?: DynamicProperty<number>;
    transparent?: boolean;
}

// @public (undocumented)
export abstract class LiteralExpr extends Expr {
    // @override (undocumented)
    protected exprIsDynamic(): boolean;
    static fromValue(value: Value): Expr;
    // (undocumented)
    abstract get value(): Value;
}

// @public
export type LiteralValue = string | number | boolean;

// @public
export type MagFilter = "nearest" | "linear";

// @public
export type MakeTechniqueAttrs<T> = {
    [P in keyof T]: T[P] | JsonExpr extends T[P] ? RemoveInterpolatedPropDef<RemoveJsonExpr<T[P]>> | Expr : T[P];
};

// @public
export class MapEnv extends Env {
    constructor(entries: ValueMap, parent?: Env | undefined);
    // (undocumented)
    readonly entries: ValueMap;
    // @override
    lookup(name: string): Value | undefined;
    // @override
    unmap(): ValueMap;
}

// @public
export interface MarkerTechniqueParams extends BaseTechniqueParams {
    alwaysOnTop?: boolean;
    backgroundColor?: DynamicProperty<StyleColor>;
    backgroundOpacity?: DynamicProperty<number>;
    backgroundSize?: DynamicProperty<number>;
    canvasRotation?: DynamicProperty<number>;
    color?: DynamicProperty<StyleColor>;
    distanceScale?: number;
    fontName?: string;
    fontStyle?: "Regular" | "Bold" | "Italic" | "BoldItalic";
    fontVariant?: "Regular" | "AllCaps" | "SmallCaps";
    hAlignment?: DynamicProperty<"Left" | "Center" | "Right">;
    iconBrightness?: number;
    iconColor?: StyleColor;
    iconFadeTime?: number;
    iconIsOptional?: boolean;
    iconMaxZoomLevel?: number;
    iconMayOverlap?: boolean;
    iconMinZoomLevel?: number;
    iconReserveSpace?: boolean;
    iconScale?: number;
    iconXOffset?: DynamicProperty<number>;
    iconYOffset?: DynamicProperty<number>;
    imageTexture?: DynamicProperty<string>;
    imageTextureField?: string;
    imageTexturePostfix?: string;
    imageTexturePrefix?: string;
    label?: string;
    leading?: DynamicProperty<number>;
    lineRotation?: DynamicProperty<number>;
    lineWidth?: DynamicProperty<number>;
    maxLines?: DynamicProperty<number>;
    minDistance?: number;
    opacity?: DynamicProperty<number>;
    placements?: string;
    poiName?: string;
    poiNameField?: string;
    poiTable?: string;
    priority?: DynamicProperty<number>;
    renderTextDuringMovements?: boolean;
    rotation?: number;
    screenHeight?: DynamicProperty<number>;
    screenWidth?: DynamicProperty<number>;
    showOnMap?: boolean;
    size?: DynamicProperty<number>;
    stackMode?: PoiStackMode;
    style?: string;
    text?: DynamicProperty<string>;
    textFadeTime?: number;
    textIsOptional?: boolean;
    textMaxZoomLevel?: number;
    textMayOverlap?: boolean;
    textMinZoomLevel?: number;
    textReserveSpace?: boolean;
    tracking?: DynamicProperty<number>;
    // @deprecated
    useAbbreviation?: boolean;
    // @deprecated
    useIsoCode?: boolean;
    vAlignment?: DynamicProperty<"Above" | "Center" | "Below">;
    worldOffset?: DynamicProperty<number>;
    wrappingMode?: DynamicProperty<"None" | "Character" | "Word">;
    xOffset?: DynamicProperty<number>;
    yOffset?: DynamicProperty<number>;
}

// @public (undocumented)
export class MatchExpr extends Expr {
    constructor(value: Expr, branches: Array<[MatchLabel, Expr]>, fallback: Expr);
    // @override (undocumented)
    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result;
    // (undocumented)
    readonly branches: Array<[MatchLabel, Expr]>;
    // @override (undocumented)
    protected exprIsDynamic(): boolean;
    // (undocumented)
    readonly fallback: Expr;
    static isValidMatchLabel(node: JsonValue): node is MatchLabel;
    // (undocumented)
    readonly value: Expr;
}

// @public (undocumented)
export type MatchLabel = number | string | number[] | string[];

// @public
export type MinFilter = "nearest" | "nearestMipMapNearest" | "nearestMipMapLinear" | "linear" | "linearMipMapNearest" | "linearMipMapLinear";

// @public
export interface MultiLineString {
    // (undocumented)
    coordinates: number[][][];
    // (undocumented)
    type: "MultiLineString";
}

// @public
export interface MultiPoint {
    // (undocumented)
    coordinates: number[][];
    // (undocumented)
    type: "MultiPoint";
}

// @public
export interface MultiPolygon {
    // (undocumented)
    coordinates: number[][][][];
    // (undocumented)
    type: "MultiPolygon";
}

// @public
export function needsVertexNormals(technique: Technique): boolean;

// @public (undocumented)
export interface NoneStyle extends BaseStyle<"none", {
    [name: string]: any;
}> {
    // (undocumented)
    [name: string]: any;
}

// @public
export class NullLiteralExpr extends LiteralExpr {
    protected constructor();
    // @override (undocumented)
    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result;
    // @override (undocumented)
    protected exprIsDynamic(): boolean;
    // (undocumented)
    static instance: NullLiteralExpr;
    // @override (undocumented)
    readonly value: Value;
}

// @public
export class NumberLiteralExpr extends LiteralExpr {
    constructor(value: number);
    // @override (undocumented)
    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result;
    // (undocumented)
    readonly value: number;
}

// @public
export class ObjectLiteralExpr extends LiteralExpr {
    constructor(value: object);
    // @override (undocumented)
    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result;
    // (undocumented)
    get isArrayLiteral(): boolean;
    // (undocumented)
    readonly value: object;
}

// @public
export interface OptionsMap {
    // (undocumented)
    [name: string]: any;
}

// @public
export function parseStringEncodedColor(color: string): number | undefined;

// @public
export function parseStringEncodedNumeral(numeral: string, pixelToMeters?: number): number | undefined;

// @public
export interface PathGeometry {
    // (undocumented)
    path: Vector3Like_2[];
}

// @public (undocumented)
export type PixelFormat = "Alpha" | "RGB" | "RGBA" | "Luminance" | "LuminanceAlpha" | "RGBE" | "Depth" | "DepthStencil" | "Red";

// @public
export enum PlacementToken {
    // (undocumented)
    Bottom = "B",
    // (undocumented)
    BottomLeft = "BL",
    // (undocumented)
    BottomRight = "BR",
    // (undocumented)
    Center = "C",
    // (undocumented)
    East = "E",
    // (undocumented)
    Left = "L",
    // (undocumented)
    North = "N",
    // (undocumented)
    NorthEast = "NE",
    // (undocumented)
    NorthWest = "NW",
    // (undocumented)
    Right = "R",
    // (undocumented)
    South = "S",
    // (undocumented)
    SouthEast = "SE",
    // (undocumented)
    SouthWest = "SW",
    // (undocumented)
    Top = "T",
    // (undocumented)
    TopLeft = "TL",
    // (undocumented)
    TopRight = "TR",
    // (undocumented)
    West = "W"
}

// @public
export interface PoiGeometry {
    imageTextures?: number[];
    // (undocumented)
    objInfos?: AttributeMap[];
    // (undocumented)
    offsetDirections?: number[];
    // (undocumented)
    positions: BufferAttribute;
    // (undocumented)
    stringCatalog?: Array<string | undefined>;
    // (undocumented)
    technique?: number;
    // (undocumented)
    texts: number[];
}

// @public
export interface Point {
    // (undocumented)
    coordinates: number[];
    // (undocumented)
    type: "Point";
}

// @public
export interface PointTechniqueParams extends BaseTechniqueParams {
    color?: DynamicProperty<StyleColor>;
    enablePicking?: boolean;
    opacity?: DynamicProperty<number>;
    size?: number;
    texture?: string;
    transparent?: boolean;
}

// @public (undocumented)
export const pointTechniquePropTypes: TechniqueDescriptor<PointTechniqueParams>;

// @public
export enum PoiStackMode {
    Hide = "hide-in-stack",
    Show = "show-in-stack",
    ShowParent = "show-parent"
}

// @public
export type PoiStyle = BaseStyle<"labeled-icon", MarkerTechniqueParams>;

// @public
export interface PoiTableDef {
    name?: string;
    poiList?: PoiTableEntryDef[];
}

// @public
export interface PoiTableEntryDef {
    altNames?: string[];
    iconMaxLevel?: number;
    iconMinLevel?: number;
    iconName?: string;
    name?: string;
    priority?: number;
    stackMode?: string;
    textMaxLevel?: number;
    textMinLevel?: number;
    visible?: boolean;
}

// @public
export interface PoiTableRef {
    name: string;
    url: string;
    useAltNamesForKey: boolean;
}

// @public
export interface PoiTechnique extends MakeTechniqueAttrs<MarkerTechniqueParams> {
    // (undocumented)
    name: "labeled-icon";
}

// @public
export interface Polygon {
    // (undocumented)
    coordinates: number[][][];
    // (undocumented)
    type: "Polygon";
}

// @public
export interface PolygonalTechniqueParams {
    lineColor?: DynamicProperty<StyleColor>;
    lineFadeFar?: DynamicProperty<number>;
    lineFadeNear?: DynamicProperty<number>;
    polygonOffset?: boolean;
    polygonOffsetFactor?: DynamicProperty<number>;
    polygonOffsetUnits?: DynamicProperty<number>;
}

// @public (undocumented)
export interface PostEffects {
    // (undocumented)
    bloom?: IBloomEffect;
    // (undocumented)
    outline?: IOutlineEffect;
    // (undocumented)
    sepia?: ISepiaEffect;
    // (undocumented)
    vignette?: IVignetteEffect;
}

// @public (undocumented)
export type RelationalOp = "<" | ">" | "<=" | ">=";

// @public (undocumented)
export type RemoveInterpolatedPropDef<T> = T | InterpolatedPropertyDefinition<any> extends T ? Exclude<T, InterpolatedPropertyDefinition<any>> : T;

// @public (undocumented)
export type RemoveJsonExpr<T> = T | JsonExpr extends T ? Exclude<T, JsonExpr> : T;

// @public
export class RequestController implements AbortController {
    constructor(priority?: number, abortController?: AbortController);
    abort(): void;
    // (undocumented)
    abortController: AbortController;
    // (undocumented)
    priority: number;
    // (undocumented)
    get signal(): AbortSignal;
}

// @public
export type ResolvedStyleDeclaration = Style & StyleSelector;

// @public
export type ResolvedStyleSet = ResolvedStyleDeclaration[];

// @public
export type SegmentsStyle = BaseStyle<"segments", SegmentsTechniqueParams>;

// @public
export interface SegmentsTechnique extends MakeTechniqueAttrs<SegmentsTechniqueParams> {
    // (undocumented)
    name: "segments";
}

// @public
export interface SegmentsTechniqueParams extends BaseTechniqueParams {
    color: DynamicProperty<StyleColor>;
    lineWidth: DynamicProperty<number>;
    opacity?: DynamicProperty<number>;
    transparent?: boolean;
}

// @public (undocumented)
export type ShaderStyle = BaseStyle<"shader", ShaderTechniqueParams>;

// @public
export interface ShaderTechnique extends MakeTechniqueAttrs<ShaderTechniqueParams> {
    // (undocumented)
    name: "shader";
}

// @public (undocumented)
export interface ShaderTechniqueMaterialParameters {
    // (undocumented)
    [name: string]: any;
}

// @public
export interface ShaderTechniqueParams extends BaseTechniqueParams {
    // (undocumented)
    [name: string]: any;
    params: ShaderTechniqueMaterialParameters;
    primitive: "point" | "line" | "segments" | "mesh";
    transparent?: boolean;
}

// @public
export type Sky = GradientSky | CubemapSky;

// @public (undocumented)
export type SolidLineStyle = BaseStyle<"solid-line" | "dashed-line", SolidLineTechniqueParams>;

// @public
export interface SolidLineTechnique extends MakeTechniqueAttrs<SolidLineTechniqueParams> {
    // (undocumented)
    name: "solid-line" | "dashed-line";
}

// @public (undocumented)
export const solidLineTechniqueDescriptor: TechniqueDescriptor<SolidLineTechnique>;

// @public
export interface SolidLineTechniqueParams extends BaseTechniqueParams, PolygonalTechniqueParams {
    caps?: DynamicProperty<LineCaps>;
    clipping?: DynamicProperty<boolean>;
    color: DynamicProperty<StyleColor>;
    dashColor?: DynamicProperty<StyleColor>;
    dashes?: DynamicProperty<LineDashes>;
    dashSize?: DynamicProperty<StyleLength>;
    drawRangeEnd?: number;
    drawRangeStart?: number;
    gapSize?: DynamicProperty<StyleLength>;
    lineWidth: DynamicProperty<StyleLength>;
    // @deprecated (undocumented)
    metricUnit?: string;
    offset?: DynamicProperty<number>;
    opacity?: DynamicProperty<number>;
    outlineColor?: DynamicProperty<StyleColor>;
    outlineWidth?: DynamicProperty<StyleLength>;
    secondaryCaps?: DynamicProperty<LineCaps>;
    secondaryCategory?: DynamicProperty<string>;
    secondaryColor?: DynamicProperty<StyleColor>;
    secondaryRenderOrder?: DynamicProperty<number>;
    secondaryWidth?: DynamicProperty<StyleLength>;
    transparent?: boolean;
}

// @public
export type SquaresStyle = BaseStyle<"squares", PointTechniqueParams>;

// @public
export interface SquaresTechnique extends MakeTechniqueAttrs<PointTechniqueParams> {
    // (undocumented)
    name: "squares";
}

// @public (undocumented)
export const squaresTechniquePropTypes: TechniqueDescriptor<SquaresTechnique>;

// @public (undocumented)
export type StandardExtrudedLineStyle = BaseStyle<"extruded-line", StandardExtrudedLineTechniqueParams>;

// @public
export interface StandardExtrudedLineTechnique extends MakeTechniqueAttrs<StandardExtrudedLineTechniqueParams> {
    // (undocumented)
    name: "extruded-line";
}

// @public
export interface StandardExtrudedLineTechniqueParams extends StandardTechniqueParams, PolygonalTechniqueParams {
    caps?: DynamicProperty<"None" | "Circle">;
    lineWidth: DynamicProperty<number>;
    shading: "standard";
}

// @public
export enum StandardGeometryKind {
    All = "_all_",
    Area = "area",
    Background = "background",
    Border = "border",
    Building = "building",
    Detail = "detail",
    Label = "label",
    Line = "line",
    Road = "road",
    Terrain = "terrain",
    Water = "water"
}

// @public (undocumented)
export type StandardStyle = BaseStyle<"standard", StandardTechniqueParams>;

// @public
export interface StandardTechnique extends MakeTechniqueAttrs<StandardTechniqueParams> {
    // (undocumented)
    name: "standard";
}

// @public
export interface StandardTechniqueParams extends BaseTechniqueParams {
    alphaMap?: string | TextureBuffer;
    // (undocumented)
    alphaMapProperties?: TextureProperties;
    alphaTest?: DynamicProperty<number>;
    bumpMap?: string | TextureBuffer;
    // (undocumented)
    bumpMapProperties?: TextureProperties;
    color?: DynamicProperty<StyleColor>;
    depthTest?: boolean;
    displacementMap?: string | TextureBuffer;
    // (undocumented)
    displacementMapProperties?: TextureProperties;
    emissive?: DynamicProperty<StyleColor>;
    emissiveIntensity?: DynamicProperty<number>;
    emissiveMap?: string | TextureBuffer;
    // (undocumented)
    emissiveMapProperties?: TextureProperties;
    // (undocumented)
    map?: string | TextureBuffer;
    // (undocumented)
    mapProperties?: TextureProperties;
    metalness?: DynamicProperty<number>;
    metalnessMap?: string | TextureBuffer;
    // (undocumented)
    metalnessMapProperties?: TextureProperties;
    normalMap?: string | TextureBuffer;
    // (undocumented)
    normalMapProperties?: TextureProperties;
    // (undocumented)
    normalMapType?: number;
    opacity?: DynamicProperty<number>;
    refractionRatio?: DynamicProperty<number>;
    roughness?: DynamicProperty<number>;
    roughnessMap?: string | TextureBuffer;
    // (undocumented)
    roughnessMapProperties?: TextureProperties;
    textureCoordinateType?: TextureCoordinateType;
    transparent?: boolean;
    vertexColors?: boolean;
    wireframe?: boolean;
}

// @public (undocumented)
export class StepExpr extends Expr {
    constructor(input: Expr, defaultValue: Expr, stops: Array<[number, Expr]>);
    // @override (undocumented)
    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result;
    // (undocumented)
    readonly defaultValue: Expr;
    // @override (undocumented)
    protected exprIsDynamic(): boolean;
    // (undocumented)
    readonly input: Expr;
    // (undocumented)
    readonly stops: Array<[number, Expr]>;
}

// @public
export const StringEncodedColorFormats: StringEncodedNumeralFormat[];

// @public
export const StringEncodedMetricFormats: StringEncodedNumeralFormat[];

// @public
export interface StringEncodedNumeralFormat {
    // (undocumented)
    decoder: (encodedValue: string, target: number[]) => boolean;
    // (undocumented)
    mask?: number;
    // (undocumented)
    readonly regExp: RegExp;
    // (undocumented)
    readonly size: number;
    // (undocumented)
    readonly type: StringEncodedNumeralType;
}

// @public (undocumented)
export const StringEncodedNumeralFormatMaxSize: number;

// @public
export const StringEncodedNumeralFormats: StringEncodedNumeralFormat[];

// @public
export enum StringEncodedNumeralType {
    // (undocumented)
    Hex = 2,
    // (undocumented)
    HSL = 5,
    // (undocumented)
    Meters = 0,
    // (undocumented)
    Pixels = 1,
    // (undocumented)
    RGB = 3,
    // (undocumented)
    RGBA = 4
}

// @public
export class StringLiteralExpr extends LiteralExpr {
    constructor(value: string);
    // @override (undocumented)
    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result;
    get promotedValue(): RGBA | Pixels | undefined;
    // (undocumented)
    readonly value: string;
}

// @public (undocumented)
export type Style = SquaresStyle | CirclesStyle | PoiStyle | LineMarkerStyle | LineStyle | SegmentsStyle | SolidLineStyle | LabelRejectionLineStyle | FillStyle | StandardStyle | BasicExtrudedLineStyle | StandardExtrudedLineStyle | ExtrudedPolygonStyle | ShaderStyle | TerrainStyle | TextTechniqueStyle | NoneStyle;

// @public
export type StyleColor = string | number;

// @public
export type StyleDeclaration = (Style & StyleSelector) | JsonExpr;

// @public
export type StyleLength = string | number;

// @public
export interface StylePriority {
    category?: string;
    group: string;
}

// @public
export interface Styles {
    // (undocumented)
    [styleSetName: string]: StyleSet;
}

// @public
export interface StyleSelector {
    final?: boolean;
    layer?: string;
    when: string | JsonExpr;
}

// @public
export type StyleSet = StyleDeclaration[];

// @public
export type Technique = SquaresTechnique | CirclesTechnique | PoiTechnique | LineMarkerTechnique | LineTechnique | SegmentsTechnique | SolidLineTechnique | FillTechnique | StandardTechnique | TerrainTechnique | BasicExtrudedLineTechnique | StandardExtrudedLineTechnique | ExtrudedPolygonTechnique | ShaderTechnique | TextTechnique | LabelRejectionLineTechnique;

// @public (undocumented)
export const techniqueDescriptors: TechniqueDescriptorRegistry;

// @public (undocumented)
export type TerrainStyle = BaseStyle<"terrain", TerrainTechniqueParams>;

// @public
export interface TerrainTechnique extends MakeTechniqueAttrs<TerrainTechniqueParams> {
    // (undocumented)
    name: "terrain";
}

// @public
export interface TerrainTechniqueParams extends StandardTechniqueParams {
    heightBasedColors?: HeightBasedColors;
    heightGradientInterpolation?: "Discrete" | "Linear" | "Cubic";
    heightGradientWidth?: number;
}

// @public
export interface TextGeometry {
    // (undocumented)
    objInfos?: AttributeMap[];
    // (undocumented)
    positions: BufferAttribute;
    // (undocumented)
    stringCatalog?: Array<string | undefined>;
    // (undocumented)
    technique?: number;
    // (undocumented)
    texts: number[];
}

// @public
export interface TextPathGeometry {
    // (undocumented)
    objInfos?: AttributeMap;
    // (undocumented)
    path: number[];
    // (undocumented)
    pathLengthSqr: number;
    // (undocumented)
    technique: number;
    // (undocumented)
    text: string;
}

// @public
export interface TextStyleDefinition {
    backgroundColor?: string;
    // (undocumented)
    backgroundOpacity?: number;
    // (undocumented)
    backgroundSize?: number;
    // (undocumented)
    canvasRotation?: number;
    color?: string;
    // (undocumented)
    fontCatalogName?: string;
    // (undocumented)
    fontName?: string;
    // (undocumented)
    fontStyle?: "Regular" | "Bold" | "Italic" | "BoldItalic";
    // (undocumented)
    fontVariant?: "Regular" | "AllCaps" | "SmallCaps";
    // (undocumented)
    hAlignment?: "Left" | "Center" | "Right";
    // (undocumented)
    leading?: number;
    // (undocumented)
    lineRotation?: number;
    // (undocumented)
    lineWidth?: number;
    // (undocumented)
    maxLines?: number;
    // (undocumented)
    name?: string;
    // (undocumented)
    opacity?: number;
    placements?: string;
    // (undocumented)
    rotation?: number;
    // (undocumented)
    size?: number;
    // (undocumented)
    tracking?: number;
    // (undocumented)
    vAlignment?: "Above" | "Center" | "Below";
    // (undocumented)
    wrappingMode?: "None" | "Character" | "Word";
}

// @public
export interface TextTechnique extends MakeTechniqueAttrs<TextTechniqueParams> {
    // (undocumented)
    name: "text";
}

// @public
export interface TextTechniqueParams extends BaseTechniqueParams {
    backgroundColor?: DynamicProperty<StyleColor>;
    backgroundOpacity?: DynamicProperty<number>;
    backgroundSize?: DynamicProperty<number>;
    canvasRotation?: DynamicProperty<number>;
    color?: DynamicProperty<StyleColor>;
    distanceScale?: number;
    fontName?: string;
    fontStyle?: "Regular" | "Bold" | "Italic" | "BoldItalic";
    fontVariant?: "Regular" | "AllCaps" | "SmallCaps";
    hAlignment?: DynamicProperty<"Left" | "Center" | "Right">;
    label?: string;
    leading?: DynamicProperty<number>;
    lineRotation?: DynamicProperty<number>;
    lineWidth?: DynamicProperty<number>;
    maxLines?: DynamicProperty<number>;
    maxZoomLevel?: number;
    mayOverlap?: boolean;
    minZoomLevel?: number;
    opacity?: DynamicProperty<number>;
    priority?: DynamicProperty<number>;
    reserveSpace?: boolean;
    rotation?: number;
    size?: DynamicProperty<number>;
    style?: string;
    text?: DynamicProperty<string>;
    textFadeTime?: number;
    tracking?: DynamicProperty<number>;
    // @deprecated
    useAbbreviation?: boolean;
    // @deprecated
    useIsoCode?: boolean;
    vAlignment?: DynamicProperty<"Above" | "Center" | "Below">;
    wrappingMode?: DynamicProperty<"None" | "Character" | "Word">;
    xOffset?: number;
    yOffset?: number;
}

// @public (undocumented)
export type TextTechniqueStyle = BaseStyle<"text", TextTechniqueParams>;

// @public
export const TEXTURE_PROPERTY_KEYS: string[];

// @public
export interface TextureBuffer {
    buffer: ArrayBuffer;
    dataTextureProperties?: DataTextureProperties;
    type: string;
}

// @public (undocumented)
export enum TextureCoordinateType {
    EquirectangularSpace = "equirectangular-space",
    FeatureSpace = "feature-space",
    TileSpace = "tile-space"
}

// @public
export function textureCoordinateType(technique: Technique): TextureCoordinateType | undefined;

// @public (undocumented)
export type TextureDataType = "UnsignedByte" | "Byte" | "Short" | "UnsignedShort" | "Int" | "UnsignedInt" | "Float" | "HalfFloat";

// @public
export interface TextureProperties {
    flipY?: boolean;
    magFilter?: MagFilter;
    minFilter?: MinFilter;
    repeatU?: number;
    repeatV?: number;
    wrapS?: WrappingMode;
    wrapT?: WrappingMode;
}

// @public
export interface Theme {
    $schema?: string;
    clearAlpha?: number;
    clearColor?: string;
    defaultTextStyle?: TextStyleDefinition;
    definitions?: Definitions;
    extends?: string | Theme | Array<string | Theme>;
    fog?: Fog;
    fontCatalogs?: FontCatalogConfig[];
    images?: ImageDefinitions;
    imageTextures?: ImageTexture[];
    labelPriorities?: string[];
    lights?: Light[];
    poiTables?: PoiTableRef[];
    priorities?: StylePriority[];
    sky?: Sky;
    styles?: Styles;
    textStyles?: TextStyleDefinition[];
    url?: string;
}

// @public
export class ThemeVisitor {
    constructor(theme: Theme);
    // (undocumented)
    readonly theme: Theme;
    visitStyles(visitFunc: (style: StyleDeclaration) => boolean): boolean;
}

// @public
export interface TileInfo {
    // (undocumented)
    readonly numBytes: number;
    // (undocumented)
    readonly setupTime: number;
    // (undocumented)
    readonly tileKey: TileKey;
    // (undocumented)
    readonly transferList?: ArrayBuffer[];
}

// @public
export const TRANSPARENCY_PROPERTY_KEYS: string[];

// @public (undocumented)
export type Value = null | boolean | number | string | object;

// @public (undocumented)
export interface ValueMap {
    // (undocumented)
    [name: string]: Value;
}

// @public
export class VarExpr extends Expr {
    constructor(name: string);
    // @override (undocumented)
    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result;
    // @override (undocumented)
    protected exprIsDynamic(): boolean;
    // (undocumented)
    readonly name: string;
}

// @public
export namespace WorkerDecoderProtocol {
    export interface ConfigurationMessage extends DecoderMessage {
        // (undocumented)
        definitions?: Definitions;
        // (undocumented)
        languages?: string[];
        // (undocumented)
        options?: OptionsMap;
        // (undocumented)
        styleSet?: StyleSet;
        // (undocumented)
        type: DecoderMessageName.Configuration;
    }
    export interface DecoderMessage {
        // (undocumented)
        service: string;
        // (undocumented)
        type: DecoderMessageName;
    }
    export enum DecoderMessageName {
        // (undocumented)
        Configuration = "configuration"
    }
    export interface DecodeTileRequest extends WorkerServiceProtocol.ServiceRequest {
        // (undocumented)
        data: ArrayBufferLike;
        // (undocumented)
        projection: string;
        // (undocumented)
        tileKey: number;
        // (undocumented)
        type: Requests.DecodeTileRequest;
    }
    export function isConfigurationMessage(message: any): message is ConfigurationMessage;
    export function isDecodeTileRequest(message: any): message is DecodeTileRequest;
    export function isTileInfoRequest(message: any): message is TileInfoRequest;
    export enum Requests {
        // (undocumented)
        DecodeTileRequest = "decode-tile-request",
        // (undocumented)
        TileInfoRequest = "tile-info-request"
    }
    export interface TileInfoRequest extends WorkerServiceProtocol.ServiceRequest {
        // (undocumented)
        data: ArrayBufferLike;
        // (undocumented)
        projection: string;
        // (undocumented)
        tileKey: number;
        // (undocumented)
        type: Requests.TileInfoRequest;
    }
}

// @public
export namespace WorkerServiceProtocol {
    const WORKER_SERVICE_MANAGER_SERVICE_ID = "worker-service-manager";
    export interface CreateServiceRequest extends ServiceRequest {
        targetServiceId: string;
        targetServiceType: string;
        // (undocumented)
        type: Requests.CreateService;
    }
    export interface DestroyServiceRequest extends ServiceRequest {
        targetServiceId: string;
        // (undocumented)
        type: Requests.DestroyService;
    }
    export interface InitializedMessage extends ServiceMessage {
        // (undocumented)
        type: ServiceMessageName.Initialized;
    }
    export function isInitializedMessage(message: any): message is InitializedMessage;
    export function isRequestMessage(message: any): message is RequestMessage;
    export function isResponseMessage(message: any): message is ResponseMessage;
    export function isUnknownServiceError(error: Error): boolean;
    export interface RequestMessage extends ServiceMessage {
        // (undocumented)
        messageId: number;
        // (undocumented)
        request: any;
        // (undocumented)
        type: ServiceMessageName.Request;
    }
    export enum Requests {
        // (undocumented)
        CreateService = "create-service",
        // (undocumented)
        DestroyService = "destroy-service"
    }
    export interface ResponseMessage extends ServiceMessage {
        // (undocumented)
        errorMessage?: string;
        // (undocumented)
        errorStack?: string;
        // (undocumented)
        messageId: number;
        // (undocumented)
        response?: object;
        // (undocumented)
        type: ServiceMessageName.Response;
    }
    export interface ServiceMessage {
        // (undocumented)
        service: string;
        // (undocumented)
        type: ServiceMessageName;
    }
    export enum ServiceMessageName {
        // (undocumented)
        Initialized = "initialized",
        // (undocumented)
        Request = "request",
        // (undocumented)
        Response = "response"
    }
    export interface ServiceRequest {
        // (undocumented)
        type: string;
    }
    export type WorkerServiceManagerRequest = CreateServiceRequest | DestroyServiceRequest;
}

// @public
export namespace WorkerTilerProtocol {
    export function isRegisterIndexRequest(message: any): message is RegisterIndexRequest;
    export function isTileRequest(message: any): message is TileRequest;
    export function isUpdateIndexRequest(message: any): message is UpdateIndexRequest;
    export interface RegisterIndexRequest extends WorkerServiceProtocol.ServiceRequest {
        // (undocumented)
        id: string;
        // (undocumented)
        input: string | GeoJson;
        // (undocumented)
        type: Requests.RegisterIndex;
    }
    export enum Requests {
        // (undocumented)
        RegisterIndex = "register-index",
        // (undocumented)
        TileRequest = "tile-request",
        // (undocumented)
        UpdateIndex = "update-index"
    }
    export interface TileRequest extends WorkerServiceProtocol.ServiceRequest {
        // (undocumented)
        index: string;
        // (undocumented)
        tileKey: number;
        // (undocumented)
        type: Requests.TileRequest;
    }
    export interface UpdateIndexRequest extends WorkerServiceProtocol.ServiceRequest {
        // (undocumented)
        id: string;
        // (undocumented)
        input: string | GeoJson;
        // (undocumented)
        type: Requests.UpdateIndex;
    }
}

// @public
export type WrappingMode = "clamp" | "repeat" | "mirror";


```
